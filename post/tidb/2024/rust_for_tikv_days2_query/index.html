<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>TiKV 源码阅读三部曲（二）读流程 - Troy的网络博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Troy" /><meta name="description" content="Tidb" /><meta name="keywords" content="daily-interview-question, Github, c&#43;&#43;, Leetcode 题解, 后端面试" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://wangcy6.github.io/post/tidb/2024/rust_for_tikv_days2_query/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="TiKV 源码阅读三部曲（二）读流程" />
<meta property="og:description" content="Tidb" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangcy6.github.io/post/tidb/2024/rust_for_tikv_days2_query/" /><meta property="article:section" content="post" />



<meta itemprop="name" content="TiKV 源码阅读三部曲（二）读流程">
<meta itemprop="description" content="Tidb">

<meta itemprop="wordCount" content="3830">
<meta itemprop="keywords" content="Tidb," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TiKV 源码阅读三部曲（二）读流程"/>
<meta name="twitter:description" content="Tidb"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="https://github.com/wangcy6/weekly/tree/master/book">
        <li class="mobile-menu-item">阅读清单</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://github.com/wangcy6/weekly/tree/master/book">阅读清单</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">TiKV 源码阅读三部曲（二）读流程</h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 00:00 </span>
        
          <span class="more-meta"> 约 3830 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#读流程">读流程</a>
      <ul>
        <li><a href="#1-开始debug">1. 开始debug</a></li>
        <li><a href="#2--kvproto-中rawget-怎么和future_raw_get-管理起来的">2.  kvproto 中RawGet 怎么和future_raw_get 管理起来的？</a></li>
        <li><a href="#3-storageraw_get流程分析">3. Storage::raw_get流程分析</a></li>
        <li><a href="#rocksdb-snapshot">RocksDB Snapshot</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考文档">参考文档</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="0001-01-01T00:00:00" title="January 1, 0001">January 1, 0001</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <p>成为tikv贡献者第二天：读请求 全链路跟踪</p>
<p><a href="https://github.com/tikv/tikv">TiKV</a> 是一个支持事务的分布式 Key-Value 数据库，</p>
<p>需要一定的前期准备才能够有能力参与 TiKV 社区的代码开发</p>
<p>回顾：</p>
<p>成为tikv贡献者第一天：搭建环境</p>
<p>介绍了 如何使用gitpod 断点调试 运行一个单元测试， 这样方面跟踪函数调用过程</p>
<p>本文是TiKV （版本7.0 ）源码阅读第二篇博客，</p>
<p>主要介绍 以一条raw_get读请求为例，介绍当前版本读请求的全链路执行流程。</p>
<p>目标</p>
<ol>
<li>通过断点调试了解RPC,KvService，Storage 之间分层关系。</li>
<li>快照与Storage 关系</li>
</ol>
<h2 id="读流程">读流程</h2>
<p>如果要做到以上读写路径的全链路追踪，最简单的方法便是从集成测试里面寻找一些 case，</p>
<p>接着从 Service 模块开始打断点，之后执行调试即可。</p>
<p>在这里推荐 <code>integrations/server/kv_service.rs</code> 中的测试，里面的 test 都会构造 <code>TiKVClient</code> 发送真实的 RPC 请求</p>
<p>且服务端也基本不包含 Mock 组件，可以完整的去追踪一条 RPC 的全链路流程。</p>
<h3 id="1-开始debug">1. 开始debug</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[test_case(test_raftstore::must_new_cluster_and_kv_client)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[test_case(test_raftstore_v2::must_new_cluster_and_kv_client)]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">test_rawkv</span><span class="p">()</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_cluster</span><span class="p">,</span><span class="w"> </span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_cluster</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&#34;v0&#34;</span><span class="p">.</span><span class="n">to_vec</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&#34;v1&#34;</span><span class="p">.</span><span class="n">to_vec</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="s">b&#34;key&#34;</span><span class="p">.</span><span class="n">to_vec</span><span class="p">(),</span><span class="w"> </span><span class="s">b&#34;v2&#34;</span><span class="p">.</span><span class="n">to_vec</span><span class="p">());</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="c1">// Raw get
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">get_req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RawGetRequest</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">get_req</span><span class="p">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="n">get_req</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">get_resp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">raw_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">get_req</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">get_resp</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>说明：还有一个测试方式  使用官方提供的client-go/client-rust直接访问PD和TiKV</p>
<h3 id="2--kvproto-中rawget-怎么和future_raw_get-管理起来的">2.  kvproto 中RawGet 怎么和future_raw_get 管理起来的？</h3>
<p><img src="D:%5Cdb%5Cdaily-interview%5Cblog%5Ccontent%5Cpost%5Ctidb%5C2024%5Cassets%5Cimage-20240716212941824.png" alt="image-20240716212941824"></p>
<p>​    kvproto 是 Protocol buffer files for TiKV 定义了RPC服务接口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">代码地址：
 https://github.com/pingcap/kvproto/blob/master/proto/tikvpb.proto
 https://tikv.github.io/doc/kvproto/tikvpb/trait.Tikv.html#tymethod.raw_get
 
service Tikv {
   // Raw commands; no transaction support.
   rpc RawGet(kvrpcpb.RawGetRequest) returns (kvrpcpb.RawGetResponse) {}
}
//语法回顾：
定义服务(Service)  如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口

</code></pre></td></tr></table>
</div>
</div><p>TiKV 包含多个 gRPC service。其中，最重要的一个是 <code>KvService</code>，位于 <code>src/server/service/kv.rs</code> 文件中。</p>
<p><strong>这里到了<code>KvService</code> 层</strong></p>
<ul>
<li>
<p>文件</p>
<p>kv.rs</p>
</li>
<li>
<p>定义类和方法。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// Service handles the RPC messages for the `Tikv` service.

// 这是一个文档注释，说明 Service 结构体用于处理 `Tikv` 服务的 RPC 消息。
pub struct Service&lt;E: Engine, L: LockManager, F: KvFormat&gt; {
    // 定义 Service 结构体，它包含泛型参数 E, L, F，分别代表不同的组件或功能。
    cluster_id: u64,
    // Service 结构体的字段，用于存储集群 ID。
    store_id: u64,
    // For handling KV requests.
    storage: Storage&lt;E, L, F&gt;,
    // Service 结构体的字段，用于处理键值（KV）请求。
    
}
 // 
impl&lt;E: Engine, L: LockManager, F: KvFormat&gt; Tikv for Service&lt;E, L, F&gt; {
    handle_request!(kv_get, future_get, GetRequest, GetResponse, has_time_detail);
    handle_request!(raw_get, future_raw_get, RawGetRequest, RawGetResponse);

</code></pre></td></tr></table>
</div>
</div><ul>
<li>宏 <code>handle_request</code>，用于简化处理 RPC 请求的函数模板</li>
</ul>
<blockquote>
<p>说明：rust  async/await  这一块不太明白</p>
<p>阅读文档：https://course.rs/advance/async/future-excuting.html</p>
</blockquote>
<p>宏在 Rust 中是一种强大的工具，允许你编写更灵活和可复用的代码。下面是对这段宏代码的逐行注释解释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 定义一个宏 `handle_request`，它接受一组模式匹配的参数。
</span><span class="c1"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handle_request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 第一个模式匹配，当提供四个参数时使用。
</span><span class="c1"></span><span class="w">    </span><span class="p">(</span><span class="cp">$fn_name</span>: <span class="nc">ident</span><span class="p">,</span><span class="w"> </span><span class="cp">$future_name</span>: <span class="nc">ident</span><span class="p">,</span><span class="w"> </span><span class="cp">$req_ty</span>: <span class="nc">ident</span><span class="p">,</span><span class="w"> </span><span class="cp">$resp_ty</span>: <span class="nc">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>定义方法</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-r" data-lang="r"><span class="o">//</span> 定义一个泛型异步函数 <span class="n">future_raw_get</span>，它接受三个泛型参数 <span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">F</span>，分别约束为 <span class="n">Engine</span><span class="p">,</span> <span class="n">LockManager</span><span class="p">,</span> <span class="n">KvFormat</span>。
<span class="n">fn</span> <span class="n">future_raw_get</span><span class="o">&lt;</span><span class="n">E</span><span class="o">:</span> <span class="n">Engine</span><span class="p">,</span> <span class="n">L</span><span class="o">:</span> <span class="n">LockManager</span><span class="p">,</span> <span class="bp">F</span><span class="o">:</span> <span class="n">KvFormat</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="o">//</span> 函数接受一个对 <span class="n">Storage</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">F</span><span class="o">&gt;</span> 类型的引用和一个 <span class="n">RawGetRequest</span> 类型的可变引用。
    <span class="n">storage</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">Storage</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="bp">F</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">mut</span> <span class="n">req</span><span class="o">:</span> <span class="n">RawGetRequest</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">ServerResult</span><span class="o">&lt;</span><span class="n">RawGetResponse</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="o">//</span> 调用 <span class="n">storage</span> 的 <span class="n">raw_get</span> 方法，传入 <span class="n">req</span> 的上下文、列族和键，并获取返回值。
    <span class="n">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">storage.raw_get</span><span class="p">(</span><span class="nf">req.take_context</span><span class="p">(),</span> <span class="nf">req.take_cf</span><span class="p">(),</span> <span class="nf">req.take_key</span><span class="p">());</span>

    <span class="o">//</span> 定义一个异步闭包，它将异步执行。
    <span class="o">//</span> <span class="n">https</span><span class="o">://</span><span class="n">rust</span><span class="o">-</span><span class="n">lang.github.io</span><span class="o">/</span><span class="n">async</span><span class="o">-</span><span class="n">book</span><span class="o">/</span><span class="m">03</span><span class="n">_async_await</span><span class="o">/</span><span class="m">01</span><span class="n">_chapter.html</span>
    <span class="n">async</span> <span class="n">move</span> <span class="p">{</span>
        <span class="o">//</span> 等待 <span class="n">v</span> 的 <span class="n">Future</span> 完成并获取结果。
        <span class="n">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v.await</span><span class="p">;</span>
        <span class="o">//</span> 创建一个 <span class="n">RawGetResponse</span> 的默认实例。
        <span class="n">let</span> <span class="n">mut</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">RawGetResponse</span><span class="o">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="o">//</span> 尝试从 <span class="n">v</span> 中提取区域错误，如果有，则设置到响应中。
        <span class="n">if</span> <span class="n">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="nf">extract_region_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">resp.set_region_error</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
        <span class="p">}</span> <span class="n">else</span> <span class="p">{</span>
            <span class="o">//</span> 根据 <span class="n">v</span> 的结果进行不同的处理。
            <span class="n">match</span> <span class="n">v</span> <span class="p">{</span>
                <span class="o">//</span> 如果获取到值，将其设置到响应的值字段中。
                <span class="o">//</span><span class="n">https</span><span class="o">://</span><span class="n">doc.rust</span><span class="o">-</span><span class="n">lang.org</span><span class="o">/</span><span class="n">std</span><span class="o">/</span><span class="n">result</span><span class="o">/</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="nf">resp.set_value</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="o">//</span> 如果没有找到值，设置响应的 <span class="n">not_found</span> 字段为 <span class="n">true</span>。
                <span class="nf">Ok</span><span class="p">(</span><span class="n">None</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">resp.set_not_found</span><span class="p">(</span><span class="n">true</span><span class="p">),</span>
                <span class="o">//</span> 如果发生错误，将错误信息格式化后设置到响应的 <span class="n">error</span> 字段中。
                <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">resp.set_error</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">)),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">//</span> 返回构建好的响应。
        <span class="nf">Ok</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>看完上面代码，我第一个疑问是 tikv 中的 region是 与key 是什么关系？</p>
<p>Region 是数据分片的基本单元，这个概念看了还是不懂，不需要记这样概念。</p>
<p>继续提问</p>
<p>TiKV 使用 region 来划分数据，每个 region 包含一定范围的键值对。</p>
<p>接下里问题就是region与Storage 关系？</p>
<p><strong>Storage</strong></p>
<p>代码路径：</p>
<p>tikv-master\src\storage\mod.rs</p>
<p>在 KVService 中， handle_request 宏将业务逻辑封装到了 future_raw_get函数中。</p>
<p>Storage 模块的raw_get函数中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/// Get the value of a raw key.
    pub fn raw_get(
        &amp;self,
        ctx: Context,
        cf: String,
        key: Vec&lt;u8&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;&gt; s
</code></pre></td></tr></table>
</div>
</div><p>具体执行的任务主要包含以下两个工作：</p>
<ul>
<li>raw get 只需要调用 engine 的 <code>async_snapshot</code> 拿到数据库快照，</li>
<li>然后直接读取就可以.</li>
</ul>
<p>下面是KvGet流程参考对比</p>
<p>TiKV作为gRPC的Server端，提供了KvGet接口的实现，相关调用堆栈为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-arduino" data-lang="arduino"><span class="o">+</span><span class="n">TiKV</span><span class="o">::</span><span class="n">kv_get</span> <span class="p">(</span><span class="n">grpc</span><span class="o">-</span><span class="n">poll</span><span class="o">-</span><span class="kr">thread</span><span class="p">)</span>
 <span class="o">+</span><span class="n">future_get</span>
  <span class="o">+</span><span class="n">Storage</span><span class="o">::</span><span class="nf">get</span>
   <span class="o">+</span><span class="n">Storage</span><span class="o">::</span><span class="n">snapshot</span> <span class="p">(</span><span class="n">readpool</span><span class="o">-</span><span class="kr">thread</span><span class="p">)</span>
   <span class="o">+</span><span class="n">SnapshotStore</span><span class="o">::</span><span class="nf">get</span>
     <span class="o">+</span><span class="n">PointGetterBuilder</span><span class="o">::</span><span class="n">build</span>
     <span class="o">+</span><span class="n">PointGetter</span><span class="o">::</span><span class="nf">get</span>
</code></pre></td></tr></table>
</div>
</div><p>在一次KvGet调用中，函数执行流程会在grpc-poll-thread和readpool-thread中切换，</p>
<p>其中前者为gRPC的poll thread，请求在被路由到Storage层后，会根据读写属性路由到不同的线程池中，</p>
<p>只读语义的Get/Scan请求都会被路由到ReadPool中执行</p>
<p><strong>Storage 是什么？</strong></p>
<p>Storage 定义在 storage/mod.rs文件中，下面我们介绍下 Storage 几个重要的成员</p>
<ul>
<li>
<p>engine：代表的是底层的 KV 存储引擎，实际上就是 RaftKV。</p>
</li>
<li>
<p>sched：事务调度器，负责并发事务请求的调度工作。</p>
</li>
<li>
<p>read_pool：读取线程池，所有只读 KV 请求，包括事务的非事务的，如 raw get、txn kv get 等最终都会在这个线程池内执行。</p>
<p>由于只读请求不需要获取 latches，所以为其分配一个独立的线程池直接执行，而不是与非只读事务共用事务调度器。</p>
</li>
<li>
<p>RawAPI仅支持最基本的针对单Key操作的Set/Get/Del及Scan语义</p>
</li>
<li>
<p>TxnAPI提供了基于ACID事务标准的接口，支持多Key写入的原子性</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">
/// [`Storage`](Storage) implements transactional KV APIs and raw KV APIs on a
/// given [`Engine`]. An [`Engine`] provides low level KV functionality.

/// [`Engine`] has multiple implementations. When a TiKV server is running, a
/// [`RaftKv`](crate::server::raftkv::RaftKv) will be the underlying [`Engine`]
/// of [`Storage`]. The other two types of engines are for test purpose.
///
/// [`Storage`] is reference counted and cloning [`Storage`] will just increase
/// the reference counter. Storage resources (i.e. threads, engine) will be
/// released when all references are dropped.
///
/// Notice that read and write methods may not be performed over full data in
/// most cases, i.e. when underlying engine is
/// [`RaftKv`](crate::server::raftkv::RaftKv), which limits data access in the
/// range of a single region according to specified `ctx` parameter. However,
/// [`unsafe_destroy_range`](crate::server::gc_worker::GcTask::
/// UnsafeDestroyRange) is the only exception. It&#39;s always performed on the
/// whole TiKV.
///
/// Operations of [`Storage`](Storage) can be divided into two types: MVCC
/// operations and raw operations. MVCC operations uses MVCC keys, which usually
/// consist of several physical keys in different CFs. In default CF and write
/// CF, the key will be memcomparable-encoded and append the timestamp to it, so
/// that multiple versions can be saved at the same time. Raw operations use raw
/// keys, which are saved directly to the engine without memcomparable- encoding
/// and appending timestamp.

pub struct Storage&lt;E: Engine, L: LockManager, F: KvFormat&gt; {
    // TODO: Too many Arcs, would be slow when clone.
    engine: E,
    sched: TxnScheduler&lt;E, L&gt;,
    /// The thread pool used to run most read operations.
    //读取线程池，所有只读 KV 请求，包括事务的和非事务的，如 raw get、txn kv get 等最终都会在这个线程池内执行
    read_pool: ReadPoolHandle,
}
</code></pre></td></tr></table>
</div>
</div><p><code>storage</code> 结构实现了在给定的 [<code>Engine</code>] 上执行事务性键值（KV）API和原始键值（KV）API</p>
<p>从raw_get开始，复杂的先不看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/// Get the value of a raw key.
pub fn raw_get(
    &amp;self,
    ctx: Context,
    cf: String,
    key: Vec&lt;u8&gt;,
) -&gt; impl Future&lt;Output = Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;&gt; {
</code></pre></td></tr></table>
</div>
</div><h3 id="3-storageraw_get流程分析">3. Storage::raw_get流程分析</h3>
<p>参考文章：</p>
<ul>
<li>PointGet的一生 <a href="https://tidb.net/blog/d6444c63">https://tidb.net/blog/d6444c63</a></li>
</ul>
<p>该方法主要执行以下几个步骤：</p>
<ol>
<li>从上下文中提取必要的信息，如优先级、任务元数据等。</li>
<li>在一个异步块中执行命令，记录和检查相关指标和时间。</li>
<li>创建快照上下文并获取快照。</li>
<li>编码键、收集查询信息并从存储中获取键值。</li>
<li>收集和记录统计数据及命令执行时间。</li>
<li>最终返回结果。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">
</span><span class="w"></span><span class="sd">/// 获取原始键的值。
</span><span class="sd">/// 
</span><span class="sd">/// 该方法接收一个上下文、列族cf和键key，返回一个Future，
</span><span class="sd">/// 输出是一个包含结果的Option&lt;Vec&lt;u8&gt;&gt;类型。
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw_get</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ctx</span>: <span class="nc">Context</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cf</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">key</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"> 
</span><span class="w">    </span><span class="c1">// 创建并启动带忙碌检查的读取池
</span><span class="c1"></span><span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">read_pool_spawn_with_busy_check</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">busy_threshold</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 增加特定命令的计数
</span><span class="c1"></span><span class="w">            </span><span class="n">KV_COMMAND_COUNTER_VEC_STATIC</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CMD</span><span class="p">).</span><span class="n">inc</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">SCHED_COMMANDS_PRI_COUNTER_VEC_STATIC</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">priority_tag</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">inc</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 检查API版本是否匹配
</span><span class="c1"></span><span class="w">            </span><span class="n">Self</span>::<span class="n">check_api_version</span><span class="p">(</span><span class="n">api_version</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">api_version</span><span class="p">,</span><span class="w"> </span><span class="n">CMD</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">key</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 记录命令持续时间
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">command_duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 创建快照上下文
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">snap_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SnapContext</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">pb_ctx</span>: <span class="kp">&amp;</span><span class="nc">ctx</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="p">..</span><span class="nb">Default</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 获取快照
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">snapshot</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">                </span><span class="n">Self</span>::<span class="n">with_tls_engine</span><span class="p">(</span><span class="o">|</span><span class="n">engine</span><span class="o">|</span><span class="w"> </span><span class="n">Self</span>::<span class="n">snapshot</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">snap_ctx</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 获取桶信息
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">buckets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">snapshot</span><span class="p">.</span><span class="n">ext</span><span class="p">().</span><span class="n">get_buckets</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 创建原始存储
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RawStore</span>::<span class="n">new</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span><span class="w"> </span><span class="n">api_version</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 获取列族信息
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">cf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">rawkv_cf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cf</span><span class="p">,</span><span class="w"> </span><span class="n">api_version</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 内部命令执行块
</span><span class="c1"></span><span class="w">            </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 记录起始时间
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">begin_instant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Statistics</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// 编码原始键
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span>::<span class="n">encode_raw_key_owned</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// 获取键值
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">raw_get_key_value</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stats</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">from</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>克服语法问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w"> </span><span class="c1">// 获取快照
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">snapshot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">with_tls_engine</span><span class="p">(</span><span class="o">|</span><span class="n">engine</span><span class="o">|</span><span class="w"> </span><span class="n">Self</span>::<span class="n">snapshot</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">snap_ctx</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">await</span><span class="o">?</span><span class="w"> </span><span class="err">用于等待异步操作完成并检查是否有错误发生。如果有错误，它将返回该错误，并使用</span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="err">引发适当的错误处理</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nc">Callback</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[inline]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">with_tls_engine</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">E</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Safety: the read pools ensure that a TLS engine exists.
</span><span class="c1"></span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">with_tls_engine</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// Get a snapshot of `engine`.
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">snapshot</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">engine</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">ctx</span>: <span class="nc">SnapContext</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">std</span>::<span class="n">future</span>::<span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">E</span>::<span class="n">Snap</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">kv</span>::<span class="n">snapshot</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">txn</span>::<span class="n">Error</span>::<span class="n">from</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">from</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>read_pool_spawn_with_busy_check</code> 的泛型函数，</p>
<p>它的作用是将一个异步任务（<code>future</code>）提交给一个读取池（<code>read_pool</code>），</p>
<p>并在提交前检查是否繁忙</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 定义一个泛型函数 read_pool_spawn_with_busy_check，它接受以下参数：
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">read_pool_spawn_with_busy_check</span><span class="o">&lt;</span><span class="n">Fut</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="c1">// &amp;self 表示这是一个方法，它借用了当前实例。
</span><span class="c1"></span><span class="w">    </span><span class="n">busy_threshold</span>: <span class="nc">Duration</span><span class="p">,</span><span class="w"> </span><span class="c1">// busy_threshold 参数，表示繁忙阈值。
</span><span class="c1"></span><span class="w">    </span><span class="n">future</span>: <span class="nc">Fut</span><span class="p">,</span><span class="w"> </span><span class="c1">// future 参数，是一个异步任务。
</span><span class="c1"></span><span class="w">    </span><span class="n">priority</span>: <span class="nc">CommandPri</span><span class="p">,</span><span class="w"> </span><span class="c1">// priority 参数，表示任务的优先级。
</span><span class="c1"></span><span class="w">    </span><span class="n">task_id</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="c1">// task_id 参数，表示任务的唯一标识符。
</span><span class="c1"></span><span class="w">    </span><span class="n">metadata</span>: <span class="nc">TaskMetadata</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// metadata 参数，包含任务的元数据。
</span><span class="c1"></span><span class="w">    </span><span class="n">resource_limiter</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">ResourceLimiter</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// resource_limiter 参数，表示资源限制器的可选引用。
</span><span class="c1"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="c1">// 返回一个实现了 Future trait 的类型，其输出是 Result&lt;T&gt; 类型。
</span><span class="c1"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Fut</span>: <span class="nc">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="c1">// Fut 必须是可发送的（Send）并且 &#39;static 生命周期，且其输出必须是 Result&lt;T&gt;。
</span><span class="c1"></span><span class="w">    </span><span class="n">T</span>: <span class="nb">Send</span> <span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="c1">// T 必须是可发送的（Send）并且 &#39;static 生命周期。
</span><span class="c1"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 检查繁忙阈值，如果返回 Err，则构造一个错误并立即返回。
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">busy_err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">read_pool</span><span class="p">.</span><span class="n">check_busy_threshold</span><span class="p">(</span><span class="n">busy_threshold</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kvproto</span>::<span class="n">errorpb</span>::<span class="n">Error</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">err</span><span class="p">.</span><span class="n">set_server_is_busy</span><span class="p">(</span><span class="n">busy_err</span><span class="p">);</span><span class="w"> </span><span class="c1">// 设置错误为服务器繁忙。
</span><span class="c1"></span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Either</span>::<span class="n">Left</span><span class="p">(</span><span class="n">future</span>::<span class="n">err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">from</span><span class="p">(</span><span class="n">ErrorInner</span>::<span class="n">Kv</span><span class="p">(</span><span class="n">err</span><span class="p">.</span><span class="n">into</span><span class="p">()))));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 如果检查通过，则将 future 任务提交给读取池。
</span><span class="c1"></span><span class="w">    </span><span class="n">Either</span>::<span class="n">Right</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read_pool</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">spawn_handle</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="c1">// 提交的异步任务。
</span><span class="c1"></span><span class="w">                </span><span class="n">priority</span><span class="p">,</span><span class="w"> </span><span class="c1">// 任务的优先级。
</span><span class="c1"></span><span class="w">                </span><span class="n">task_id</span><span class="p">,</span><span class="w"> </span><span class="c1">// 任务的唯一标识符。
</span><span class="c1"></span><span class="w">                </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="c1">// 任务的元数据。
</span><span class="c1"></span><span class="w">                </span><span class="n">resource_limiter</span><span class="p">,</span><span class="w"> </span><span class="c1">// 资源限制器的可选引用。
</span><span class="c1"></span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">Error</span>::<span class="n">from</span><span class="p">(</span><span class="n">ErrorInner</span>::<span class="n">SchedTooBusy</span><span class="p">))</span><span class="w"> </span><span class="c1">// 将 spawn_handle 可能的错误转换为统一的错误类型。
</span><span class="c1"></span><span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">res</span><span class="o">|</span><span class="w"> </span><span class="n">future</span>::<span class="n">ready</span><span class="p">(</span><span class="n">res</span><span class="p">)),</span><span class="w"> </span><span class="c1">// 使用 and_then 来处理 spawn_handle 的结果。
</span><span class="c1"></span><span class="w">    </span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="rocksdb-snapshot">RocksDB Snapshot</h3>
<p>这一块没有看懂 TiKV 功能介绍 – Lease Read</p>
<h2 id="小结">小结</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-arduino" data-lang="arduino"><span class="o">+</span><span class="n">TiKV</span><span class="o">::</span><span class="n">kv_get</span> <span class="p">(</span><span class="n">grpc</span><span class="o">-</span><span class="n">poll</span><span class="o">-</span><span class="kr">thread</span><span class="p">)</span>
 <span class="o">+</span><span class="n">future_get</span>
  <span class="o">+</span><span class="n">Storage</span><span class="o">::</span><span class="nf">get</span>
   <span class="o">+</span><span class="n">Storage</span><span class="o">::</span><span class="n">snapshot</span> <span class="p">(</span><span class="n">readpool</span><span class="o">-</span><span class="kr">thread</span><span class="p">)</span>
   <span class="o">+</span><span class="n">SnapshotStore</span><span class="o">::</span><span class="nf">get</span>
     <span class="o">+</span><span class="n">PointGetterBuilder</span><span class="o">::</span><span class="n">build</span>
     <span class="o">+</span><span class="n">PointGetter</span><span class="o">::</span><span class="nf">get</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考文档">参考文档</h2>
<ul>
<li>【1】RaftStorage <a href="https://xieyu.github.io/blog/tikv/thread_local_engine.html">https://xieyu.github.io/blog/tikv/thread_local_engine.html</a></li>
<li>【2】PointGet的一生  <a href="https://tidb.net/blog/d6444c63">https://tidb.net/blog/d6444c63</a></li>
<li>【3】<a href="https://course.rs/advance/concurrency-with-threads/send-sync.html#%E5%9F%BA%E4%BA%8E-send-%E5%92%8C-sync-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">基于 Send 和 Sync 的线程安全</a></li>
<li>[4] <a href="https://alexstocks.github.io/html/rocksdb.html">https://alexstocks.github.io/html/rocksdb.html</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Troy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01 00:00
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/nusr/blog/blob/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Tidb/">Tidb</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/oceanbase/2011/03_mimi_ob/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">mimob代码阅读</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/tidb/2024/rust_for_tikv_days3_read/">
            <span class="next-text nav-default">T成为tikv贡献者第三天：</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="wangcy6/wangcy6.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wang_cyi@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/wangcy6" class="iconfont icon-github" title="github"></a>
  <a href="https://wangcy6.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Troy</span>
  </span>
</div>
<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138883536-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
