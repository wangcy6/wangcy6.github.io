<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的 - Troy的网络博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Troy" /><meta name="description" content="do book" /><meta name="keywords" content="daily-interview-question, Github, c&#43;&#43;, Leetcode 题解, 后端面试" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://wangcy6.github.io/post/interview/interviewSystemDesgin/2025/day22-system-desgin-1.0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的" />
<meta property="og:description" content="do book" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangcy6.github.io/post/interview/interviewSystemDesgin/2025/day22-system-desgin-1.0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-08-07T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-08-07T00:00:00&#43;00:00" />

<meta itemprop="name" content="从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的">
<meta itemprop="description" content="do book"><meta itemprop="datePublished" content="2024-08-07T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2024-08-07T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="9738">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的"/>
<meta name="twitter:description" content="do book"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="https://github.com/wangcy6/weekly/tree/master/book">
        <li class="mobile-menu-item">阅读清单</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://github.com/wangcy6/weekly/tree/master/book">阅读清单</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的</h1>

      <div class="post-meta">
        <span class="post-time"> 2024-08-07 00:00 </span>
        <div class="post-category">
            <a href="/categories/do-book/"> do book </a>
            </div>
          <span class="more-meta"> 约 9738 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-性能数据汇总">1. 性能数据汇总：</a></li>
    <li><a href="#2-ddn-全闪存存储机型对比表">2. DDN 全闪存存储机型对比表​</a></li>
    <li><a href="#3-符合常识吗">3 符合常识吗？</a></li>
    <li><a href="#4-lustre文件系统架构图">4. Lustre文件系统架构图</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#21--性能数据汇总">2.1  性能数据汇总：</a></li>
    <li><a href="#22--机型配置">2.2  机型配置</a>
      <ul>
        <li><a href="#ibm-storage-scale-系统规格对比">IBM Storage Scale 系统规格对比</a></li>
        <li><a href="#参数解读">参数解读</a></li>
      </ul>
    </li>
    <li><a href="#23--ibm-spectrum-scalegpfs-架构">2.3  IBM Spectrum Scale(GPFS) 架构</a>
      <ul>
        <li></li>
        <li><a href="#什么架构设计支持高性能">什么架构设计支持高性能</a></li>
        <li><a href="#疑问上面我没看懂-元数据怎么查找一个文件的">疑问：上面我没看懂 元数据怎么查找一个文件的</a></li>
        <li><a href="#核心思想像查字典一样找文件">核心思想：像查字典一样找文件</a></li>
        <li><a href="#总结与优势">总结与优势</a></li>
      </ul>
    </li>
    <li><a href="#疑问-如果目录大小发生了变化不是整个数据重新分配吗">疑问： 如果目录大小发生了变化，不是整个数据重新分配吗？</a></li>
    <li><a href="#1-目录大小变化--数据重新分配">1️⃣ 目录大小变化 ≠ 数据重新分配</a></li>
    <li><a href="#2-案例理解">2️⃣ 案例理解</a></li>
    <li><a href="#3-核心结论">3️⃣ 核心结论</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="hint">
      <p>【注意】最后更新于 <span class="timeago" datetime="2024-08-07T00:00:00" title="August 7, 2024">August 7, 2024</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <p><a href="https://wnso49yyot.feishu.cn/base/Wi37bwBTiaCpEZsFxavckkV5nbb?table=tblPUqR3ZoqKKLNW&amp;view=vew40mV0G2">https://wnso49yyot.feishu.cn/base/Wi37bwBTiaCpEZsFxavckkV5nbb?table=tblPUqR3ZoqKKLNW&amp;view=vew40mV0G2</a></p>
<p>书接上回：</p>
<p><a href="https://mp.weixin.qq.com/s/Zr-8CHOxMSl67FsKihsoTQ">从零实现分布式文件系统(二) 如何在不升级硬件的前提下,小文件并发读写性能提升十倍</a></p>
<p>*<strong>C++周刊系统设篇 目标</strong>：</p>
<ul>
<li>
<p>不是让你成为<strong>C++专家</strong>， 而是让你成为<strong>C++面试专家</strong>。</p>
</li>
<li>
<p>不是让你疯狂学习新知识， 而是帮你<strong>重新整理已有知识</strong>， 让你的能力与面试题精准对齐。。</p>
</li>
</ul>
<p><strong>知识地图：</strong></p>
<ul>
<li>操作系统&ndash;文件子系统&ndash;AI时时代分布式文件系统</li>
<li>计划安排：<img src="https://mmbiz.qpic.cn/mmbiz_png/DMCnyCrhia36iaMAgdk7ib4vIrpf6urrNhdmqVHib41GQAGXDMTPDvib0Ue3LROIocBSCflxytXXVoiap04lR7kOMfwA/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=webp" alt=""></li>
</ul>
<p><strong>本期任务</strong>：</p>
<ul>
<li>从零开发分布式文件系统(一) :100G读写带宽,百万IO请求文件系统怎么实现的？</li>
<li>思考1：可扩展哈希（Extendible Hashing）与普通的哈希有什么区别？</li>
<li>思考2：对象和条带有什么区别？</li>
</ul>
<p><strong>一页 ppt 汇报：</strong></p>
<ul>
<li>方法： 竞标分析 要求：准确说清楚 文件系统系统 具体公司 具体机型 具体指标</li>
</ul>
<p><img src="https://s2.loli.net/2025/08/28/fBYkMZT1NOxr56V.png" alt="高配：要不起&ndash;IBM SSS 6000"></p>
<table>
<thead>
<tr>
<th>​<strong>​类型​</strong>​</th>
<th>​<strong>​厂商​</strong>​</th>
<th>​<strong>​文件系统​</strong>​</th>
<th>​<strong>​机型​</strong>​</th>
<th>​<strong>​关键配置​</strong>​</th>
<th>​<strong>​单节点聚合带宽​</strong>​</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>​<strong>​读​</strong>​</td>
</tr>
<tr>
<td>​<strong>​全闪​</strong>​</td>
<td>DDN</td>
<td>Lustre</td>
<td>SFA200NVX2E</td>
<td>双控双路，24×NVMe SSD</td>
<td>48 GB/s</td>
</tr>
<tr>
<td></td>
<td>IBM</td>
<td>GPFS (GNR模式)</td>
<td>ESS 3500</td>
<td>双控双路，24×NVMe SSD</td>
<td>​<strong>​80 GB/s​</strong>​</td>
</tr>
<tr>
<td></td>
<td>浪潮</td>
<td>GPFS (ECE模式)</td>
<td>HN12</td>
<td>8×NVMe SSD</td>
<td>21.71 GB/s</td>
</tr>
<tr>
<td>​<strong>​混闪​</strong>​</td>
<td>DDN</td>
<td>Lustre</td>
<td>SFA7990X</td>
<td>1×SFA7990X控制器 + 1×4U90磁盘柜</td>
<td>20 GB/s</td>
</tr>
<tr>
<td></td>
<td>IBM</td>
<td>GPFS (GNR模式)</td>
<td>ESS 3500</td>
<td>​<strong>​1×ESS 3500控制器 + 4×4U102扩展柜​</strong>​</td>
<td>43.2 GB/s</td>
</tr>
<tr>
<td></td>
<td>浪潮</td>
<td>GPFS (ECE模式)</td>
<td>H60</td>
<td>60×HDD（无SSD缓存）</td>
<td>5.65 GB/s</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>结论：</li>
</ul>
<ol>
<li><strong>​带宽王者​</strong>​：IBM ESS 3500 全闪以 ​<strong>​80 GB/s 读带宽​</strong>​位居榜首（需 200Gb 网络支持）。</li>
<li>​<strong>​混闪均衡​</strong>​：DDN SFA7990X 读写对称（20 GB/s），适合平衡型负载。</li>
<li>​<strong>​低成本方案​</strong>​：浪潮 H60 纯 HDD 配置成本最低，但性能仅为混闪方案的 1/4。</li>
</ol>
<h1 id="一-ddn公司的lustre文件系统">一、 DDN公司的Lustre文件系统</h1>
<h2 id="1-性能数据汇总">1. 性能数据汇总：</h2>
<table>
<thead>
<tr>
<th>​<strong>​机型​</strong>​</th>
<th>​<strong>​类型​</strong>​</th>
<th>​<strong>​厂商​</strong>​</th>
<th>​<strong>​文件系统​</strong>​</th>
<th>​<strong>​单节点聚合带宽​</strong>​</th>
<th>​<strong>​元数据OPS​</strong>​</th>
<th>​<strong>​关键限制与适配场景​</strong>​</th>
<th>核心优势​​</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​SFA7990X​</strong>​</td>
<td>混闪</td>
<td>DDN</td>
<td>Lustre</td>
<td>读：20 GB/s  <!-- raw HTML omitted -->写：20 GB/s</td>
<td>20万 OPS</td>
<td>​<strong>​必须配 SSD 元数据盘​</strong>​  <!-- raw HTML omitted -->适用：归档、冷数据处理</td>
<td>高容量性价比、70万 IOPS</td>
</tr>
<tr>
<td>​<strong>​SFA200NVX2E​</strong>​</td>
<td>全闪</td>
<td>DDN</td>
<td>Lustre</td>
<td>读：48 GB/s  <!-- raw HTML omitted -->写：38 GB/s</td>
<td>200万 OPS</td>
<td>​<strong>​单网卡带宽≤25GB/s​</strong>​  <!-- raw HTML omitted -->适用：AI推理、中型 HPC</td>
<td>极致低延迟、高吞吐</td>
</tr>
<tr>
<td>​<strong>​SFA400NVX2E​</strong>​</td>
<td>旗舰全闪</td>
<td>DDN</td>
<td>EXAScaler</td>
<td>读：≥80 GB/s  <!-- raw HTML omitted -->写：56–72 GB/s</td>
<td>≥1.2M</td>
<td>​<strong>​需 200Gb EDR 双网卡聚合​</strong>​  <!-- raw HTML omitted -->适用：AI训练、超算</td>
<td>厂商白皮书 + 行业测试</td>
</tr>
</tbody>
</table>
<p>参考：陈道碧_DDN 持续支持 Lustre 社区发展</p>
<h2 id="2-ddn-全闪存存储机型对比表">2. DDN 全闪存存储机型对比表​</h2>
<ul>
<li><a href="http://lustrefs.cn/wp-content/uploads/2023/11/CLUG2023_03_%E9%99%88%E9%81%93%E7%A2%A7_DDN%E6%8C%81%E7%BB%AD%E6%94%AF%E6%8C%81Lustre%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B1%95.pdf">陈道碧_DDN持续支持Lustre社区发展</a></li>
</ul>
<p><img src="https://s2.loli.net/2025/08/02/sgreaAvihUZz9Vq.png" alt=""></p>
<table>
<thead>
<tr>
<th>​<strong>​配置项​</strong>​</th>
<th>​<strong>​ES200NVX2 机型​</strong>​</th>
<th>​<strong>​ES400NVX2 机型​</strong>​</th>
<th>​<strong>​性能差异​</strong>​</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​架构设计​</strong>​</td>
<td>双控双路</td>
<td>双控四路</td>
<td>CPU 性能翻倍 ↑↑</td>
</tr>
<tr>
<td>​<strong>​处理器​</strong>​</td>
<td>2× 第三代英特尔®至强®可扩展处理器</td>
<td>4× 第三代英特尔®至强®可扩展处理器</td>
<td>计算密度 +100%</td>
</tr>
<tr>
<td>​<strong>​主机端口​</strong>​</td>
<td>4× HDR/HDR100 或 200/100GbE</td>
<td>8× HDR/HDR100 或 200/100GbE</td>
<td>网络带宽翻倍 ↑↑</td>
</tr>
<tr>
<td>​<strong>​驱动器支持​</strong>​</td>
<td>24× 2.5&quot; 双端口热插拔 NVMe SSD</td>
<td>24× 2.5&quot; 双端口 NVMe SSD +  <!-- raw HTML omitted -->​<strong>​SAS-4扩展（支持900块HDD/SSD）​</strong>​</td>
<td>容量扩展能力 ↑↑</td>
</tr>
<tr>
<td>​<strong>​顺序读带宽​</strong>​ 🔥</td>
<td>​<strong>​48 GB/s​</strong>​</td>
<td>​<strong>​90 GB/s​</strong>​</td>
<td>​<strong>​+87%​</strong>​</td>
</tr>
<tr>
<td>​<strong>​顺序写带宽​</strong>​ ⚡</td>
<td>​<strong>​38 GB/s​</strong>​</td>
<td>​<strong>​65 GB/s​</strong>​</td>
<td>​<strong>​+71%​</strong>​</td>
</tr>
<tr>
<td>​<strong>​随机IOPS​</strong>​ 💥</td>
<td>​<strong>​150万​</strong>​</td>
<td>​<strong>​300万​</strong>​</td>
<td>​<strong>​+100%​</strong>​</td>
</tr>
<tr>
<td>​<strong>​RAID特性​</strong>​</td>
<td>解耦式RAID (DCR)：  <!-- raw HTML omitted -->支持 RAID 6/5/1 多种纠删码</td>
<td>同左</td>
<td>相同</td>
</tr>
<tr>
<td>​<strong>​文件系统型号​</strong>​</td>
<td>EXAScaler ES200NVX2</td>
<td>EXAScaler ES400NVX2 / ​<strong>​AI400X2​</strong>​（AI专用优化）</td>
<td>场景适配扩展 ↑</td>
</tr>
</tbody>
</table>
<p>SFA200NVX2E机型</p>
<ul>
<li>
<p>24×NVMe SSD（单PCIe 5.0SSD百万ops， 实际10–14 GB/s）</p>
</li>
<li>
<p>200Gb InfiniBand（单网卡最多25GB/s带宽）</p>
</li>
<li>
<p><img src="https://s2.loli.net/2025/08/02/bIYPcCakZBh9jdK.png" alt="机型对比"></p>
</li>
</ul>
<hr>
<ul>
<li>​<strong>​追求极致性能​</strong>​ → ​<strong>​ES400NVX2​</strong>​：<br>
四路CPU + 8×200Gb端口 + 300万IOPS，适配超90GB/s带宽场景。</li>
<li>​<strong>​性价比之选​</strong>​ → ​<strong>​ES200NVX2​</strong>​：<br>
双路CPU + 全闪配置，满足中等规模HPC需求（≤50GB/s）。</li>
<li>​<strong>​AI专属优化​</strong>​ → ​<strong>​AI400X2型号​</strong>​：<br>
深度集成NVIDIA GPUDirect，减少数据搬移延迟，提速训练效率。
<img src="https://s2.loli.net/2025/08/02/7wrQUDLZh3PNjEH.png" alt=""></li>
</ul>
<h2 id="3-符合常识吗">3 符合常识吗？</h2>
<p> ​<strong>​关键数据一致性验证​</strong>​</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>SFA200NVX2E（原始值）</th>
<th>SFA400NVX2E（升级验证）</th>
<th>逻辑关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>单NVMe SSD带宽</td>
<td>2 GB/s (读) ×24盘</td>
<td>PCIe 5.0单盘≈14 GB/s</td>
<td>✅ 合理</td>
</tr>
<tr>
<td>总读带宽</td>
<td>48 GB/s</td>
<td>≥80 GB/s</td>
<td>✅ 翻倍提升</td>
</tr>
<tr>
<td>网卡限制 vs 需求带宽</td>
<td>25 GB/s &laquo; 48 GB/s</td>
<td>50 GB/s ≥ 80 GB/s*</td>
<td>SFA400需多链路聚合</td>
</tr>
</tbody>
</table>
<blockquote>
<p>​<strong>​注​</strong>​：SFA400NVX2E 的80GB/s带宽需依赖​<strong>​多网卡负载均衡​</strong>​（如4×200Gb EDR = 100GB/s理论值）。</p>
</blockquote>
<h2 id="4-lustre文件系统架构图">4. Lustre文件系统架构图</h2>
<ul>
<li><strong>Lustre</strong> 是一款专为高性能计算（HPC）环境设计的并行分布式文件系统，最初在美国政府资助下，由多个国家实验室联合开发，旨在支持大规模科学研究和工程计算任务。当前，Lustre 的主要开发与维护由 <strong>DDN（DataDirect Networks）</strong> 负责，广泛应用于超算中心、科研机构及企业级 HPC 集群中</li>
<li>Lustre 为扩展性和性能目的设计。它的存储容量和聚合性能随着<strong>服务器增加不断扩展</strong>，并且提供给并行应用的性能可以随<strong>着客户端的增加而增长</strong> 【疑问】</li>
</ul>
<p>为什么Lustre文件系统 性能随着 服务器增加不断扩展，</p>
<p>客户端的增加而增长?这个不符合常理，
例如单机下无能无限增加线程个数？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">          Client 节点
   +----------------------+
   | Lustre Client 驱动    |
   +----------------------+
           │
   ┌───────┴─────────┐
   │                 │
元数据面            数据面
   │                 │
+--------+       +--------+
|  MDS   |       |  OSS   |  ← 两类 Lustre 进程
+--------+       +--------+
    │                │
+--------+       +--------+
|  MDT   |       |  OST   |  ← 磁盘卷（Targets）
+--------+       +--------+


</code></pre></td></tr></table>
</div>
</div><p><img src="https://s2.loli.net/2025/08/28/xL6wocpIEPFbvue.png" alt="lustre"></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能与说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Client</strong></td>
<td>提供用户访问接口，支持 POSIX 文件语义，与 OSS/MDS 通信</td>
</tr>
<tr>
<td><strong>LNet</strong></td>
<td>网络通信层，支持高吞吐与 RDMA，连接所有 Lustre 架构节点</td>
</tr>
<tr>
<td><strong>MGS + MGT</strong></td>
<td>系统配置中心，负责节点启动和配置同步</td>
</tr>
<tr>
<td><strong>MDS + MDT</strong></td>
<td>管理文件系统命名空间和元数据，只在打开等元操作时被访问</td>
</tr>
<tr>
<td><strong>OSS + OST</strong></td>
<td>存储实际文件数据，处理高并发 I/O，并可扩展横向容量与性能</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="疑问mds-与-mdtoss-与-ost关系总结">疑问：MDS 与 MDT、OSS 与 OST：关系总结</h4>
<table>
<thead>
<tr>
<th>层面</th>
<th>管理者（Server）</th>
<th>存储目标（Target）</th>
<th>数量关系</th>
<th>是否独立进程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元数据</strong></td>
<td>MDS 进程</td>
<td>MDT 磁盘卷</td>
<td>通常 1:1，可通过 DNE 扩展到 1:N</td>
<td>MDS 是进程，MDT 是磁盘卷</td>
</tr>
<tr>
<td><strong>数据</strong></td>
<td>OSS 进程</td>
<td>OST 磁盘卷</td>
<td>通常 1:N，典型一台 OSS 挂 4-16 个 OST</td>
<td>OSS 是进程，OST 是磁盘卷</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1. OSS + OST：数据面</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Lustre 的数据读写路径由 <strong>Object Storage Server (OSS)</strong> 和 <strong>Object Storage Target (OST)</strong> 共同完成。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>类型</th>
<th>部署形态</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>OSS</strong></td>
<td>进程</td>
<td>运行在服务器上</td>
<td>接收客户端 I/O 请求，将其映射到 OST</td>
</tr>
<tr>
<td><strong>OST</strong></td>
<td>磁盘卷（target）</td>
<td>通常是挂载在 OSS 上的一块文件系统</td>
<td>存储实际的数据对象</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>OSS 是进程</strong>，是 <code>lustre</code> 核心模块的一部分，负责协议处理。</p>
</li>
<li>
<p><strong>OST 是磁盘卷</strong>，是 OSS 管理的存储目标，通常格式化成 <strong>ldiskfs</strong> 或 <strong>ZFS</strong>。</p>
</li>
<li>
<p><strong>1 台 OSS 通常管理多个 OST</strong>，例如一台 OSS 服务器挂载 8 块 OST 磁盘卷。</p>
</li>
</ul>
<blockquote>
<p><strong>并发优化</strong><br>
每个 OST 独立处理 I/O，客户端可并行访问多个 OST，因此 Lustre 能横向扩展读写性能。</p>
</blockquote>
<hr>
<p><strong>2. MDS + MDT：元数据面</strong></p>
<p>元数据操作由 <strong>Metadata Server (MDS)</strong> 和 <strong>Metadata Target (MDT)</strong> 完成。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>类型</th>
<th>部署形态</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MDS</strong></td>
<td>进程</td>
<td>运行在元数据服务器上</td>
<td>处理目录操作、文件名、inode、权限等</td>
</tr>
<tr>
<td><strong>MDT</strong></td>
<td>磁盘卷（target）</td>
<td>挂载在 MDS 上的元数据存储卷</td>
<td>存储 inode、dentry、ACL 等元数据信息</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>MDS 是进程</strong>，负责管理客户端的元操作。</p>
</li>
<li>
<p><strong>MDT 是磁盘卷</strong>，存储实际元数据，格式通常是 <strong>ldiskfs</strong> 或 <strong>ZFS</strong>。</p>
</li>
<li>
<p><strong>一个 MDS 通常管理一个 MDT</strong>，但 Lustre 2.7+ 开始支持 <strong>DNE（Distributed Namespace Environment）</strong>：</p>
<ul>
<li>多个 MDT 可以并行服务，命名空间分布到多个 MDT 上。</li>
<li>客户端会根据路径自动访问对应的 MDT。</li>
<li>类似“目录级别分片”，显著扩展元数据吞吐。</li>
</ul>
</li>
</ul>
<h4 id="疑问为什么lustre文件系统-性能随着-服务器增加不断扩展客户端的增加而增长这个不符合常理例如单机下无能无限增加线程个数">疑问：为什么Lustre文件系统 性能随着 服务器增加不断扩展，客户端的增加而增长?这个不符合常理，例如单机下无能无限增加线程个数？</h4>
<p><img src="https://s2.loli.net/2025/08/28/rVkoyu7zp4Tjs9U.png" alt=""></p>
<p><strong>直观理解：HPC 实例</strong></p>
<p>例如 <strong>DDN EXAScaler</strong>（DDN 商业化 Lustre）：</p>
<ul>
<li>1 个 OSS：4 块 OST，每 OST 10GB/s → 单节点带宽 ≈ 40GB/s</li>
<li>4 个 OSS：≈ 160GB/s</li>
<li>32 个 OSS：≈ 1.28TB/s</li>
</ul>
<p>如果客户端也有足够多计算节点，整个系统总吞吐量可以接近线性扩展​</p>
<p>Lustre 性能随服务器和客户端数增加而扩展，原因在于：</p>
<ol>
<li>
<p><strong>元数据与数据面解耦</strong> → 消除单点瓶颈。</p>
</li>
<li>
<p><strong>文件条带化</strong> → 单文件可并行跨 OST 访问。</p>
</li>
<li>
<p>Lustre 的文件不是放在一台服务器上，而是被 <strong>条带化</strong> 存放在多个 OST 上：</p>
</li>
</ol>
<ul>
<li>
<p>当创建大文件时，客户端从 MDS 获取到 <strong>文件条带布局</strong>。</p>
</li>
<li>
<p>文件被切分为一系列固定大小的“条带”（Stripe），每个条带写入不同的 OST。</p>
</li>
<li>
<p>客户端在写入或读取时，<strong>直接并行访问所有相关的 OST</strong></p>
</li>
</ul>
<ol start="4">
<li>
<p><strong>多 OSS/OST 架构</strong> → 数据 I/O 可以横向扩展。</p>
</li>
<li>
<p><strong>客户端并发利用更多 OSS</strong> → 随客户端数增加而扩展。</p>
</li>
<li>
<p><strong>高性能网络 LNet</strong> → 支撑海量并行 I/O。</p>
</li>
</ol>
<h4 id="与ceph-设计有什么区别">与ceph 设计有什么区别？</h4>
<p><strong>为什么 Lustre 性能能随服务器与客户端线性扩展，而 Ceph 不一定</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th><strong>Lustre</strong>（高性能并行文件系统）</th>
<th><strong>Ceph</strong>（分布式对象/块/文件存储）</th>
<th>影响性能线性扩展的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心设计目标</strong></td>
<td>HPC + AI + 大规模并行计算场景</td>
<td>云存储 + 海量数据可靠性 + 灵活性</td>
<td>Lustre 为高并发优化，Ceph 为一致性优化</td>
</tr>
<tr>
<td><strong>I/O 模型</strong></td>
<td>POSIX 文件系统语义，<strong>强条带化（striping）</strong>，直接访问 OST</td>
<td>基于 RADOS 对象存储，客户端 I/O 通过 CRUSH 算法路由到 OSD</td>
<td>Ceph 的对象访问存在更多逻辑层和元数据处理开销</td>
</tr>
<tr>
<td><strong>数据分布方式</strong></td>
<td>显式条带化：同一个大文件被拆分到多个 OST，<strong>客户端并行读写</strong></td>
<td>CRUSH 哈希分布：每个对象落在单个 OSD 上，<strong>单对象无法多 OSD 并行</strong></td>
<td>Lustre 可天然利用更多存储节点；Ceph 需要多对象并行</td>
</tr>
<tr>
<td><strong>元数据服务器 (MDS)</strong></td>
<td>元数据集中管理，但支持多 MDS 扩展，<strong>元数据和数据分离</strong></td>
<td>元数据嵌入到对象映射，依赖 CRUSH 算法，扩展性受限</td>
<td>Ceph 元数据分布较好，但每次访问仍需计算 CRUSH</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td><strong>LNet 高性能网络</strong>，支持 RDMA，带宽与 OSS/客户端线性扩展</td>
<td>使用 TCP/IP + librados，支持 RDMA 但协议栈复杂</td>
<td>Lustre 网络更薄更快，Ceph 协议栈更重</td>
</tr>
<tr>
<td><strong>性能瓶颈</strong></td>
<td>理论上无中心瓶颈，主要瓶颈在单 OST 硬件带宽</td>
<td><strong>PG（Placement Group）重平衡</strong>、OSD 内部一致性、写放大</td>
<td>Ceph 为高可靠设计，性能受一致性与复制牵制</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>HPC、AI 训练、科学计算、TOP500 超算</td>
<td>云对象存储、K8s 持久卷、海量备份、视频平台</td>
<td>目标不同导致架构取舍不同</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="核心原因总结"><strong>核心原因总结</strong></h4>
<ol>
<li>
<p><strong>Lustre 条带化 + 并行访问</strong></p>
<ul>
<li>单个大文件被切分到多个 OST。</li>
<li>多客户端可同时并行访问文件的不同块，几乎线性扩展。</li>
</ul>
</li>
<li>
<p><strong>Ceph 单对象单 OSD</strong></p>
<ul>
<li>单个对象只能落在一个 OSD 上，无法像 Lustre 那样在对象内部并行。</li>
<li>即使有 100 个 OSD，访问一个 1TB 文件仍然是单对象单 OSD。</li>
<li>想并行只能手动切分对象，增加复杂度。</li>
</ul>
</li>
<li>
<p><strong>网络协议栈不同</strong></p>
<ul>
<li>
<p>Lustre 的 <strong>LNet</strong> 专为 HPC 优化。</p>
</li>
<li>
<p>Ceph 基于 librados + TCP，协议更通用但开销更大。</p>
</li>
</ul>
</li>
<li>
<p><strong>一致性 vs 吞吐量</strong></p>
<ul>
<li>Lustre 追求<strong>极致吞吐</strong>，牺牲数据可靠性（一般依赖 RAID 层解决）。</li>
<li>Ceph 追求<strong>强一致 + 高可靠</strong>，天然限制了线性扩展。</li>
</ul>
</li>
</ol>
<h4 id="疑问条带化-和对象区别">疑问：条带化 和对象区别？</h4>
<p>困惑：</p>
<p>你觉得 <strong>Ceph 一个文件被切成多个对象</strong>，这些对象分散在不同的 <strong>PG</strong>，不同的 <strong>OSD</strong> 上，所以<strong>理论上不是应该可以并行读写吗</strong>？</p>
<p>答案是：<strong>可以并行，但并行度和 Lustre 的架构比起来有本质差异</strong>，并不是“自动无限扩展”，原因主要在于 <strong>条带化 vs. 对象分布策略</strong>。</p>
<hr>
<p><strong>1. Ceph：文件 → RADOS 对象 → PG → OSD</strong></p>
<ul>
<li>Ceph 的存储核心是 <strong>RADOS</strong>，它把上层文件（或块）切分成 <strong>对象</strong>，默认大小常见是 <strong>4MB</strong>。</li>
<li>每个对象通过 <strong>CRUSH 算法</strong>映射到某个 <strong>PG</strong>（Placement Group）。</li>
<li>PG 再映射到 1~3 个 OSD（取决于副本数）。</li>
<li>这意味着：
<ul>
<li><strong>一个对象只能被一个主 OSD 管理</strong></li>
<li>同一个对象的读写是<strong>串行的</strong>，不会跨 OSD 并行</li>
<li>文件的并行度上限 = 文件被切分的对象数 = <code>文件大小 / 对象大小</code></li>
</ul>
</li>
</ul>
<p><strong>例子</strong><br>
假设你有一个 1TB 的大文件：</p>
<ul>
<li>默认对象大小 4MB → 会切成 <strong>25 万个对象</strong></li>
<li>这 25 万个对象分布到不同的 OSD → 理论上可并行</li>
<li>但是：
<ol>
<li><strong>客户端 IO 请求是顺序的</strong> → 大多数应用一次只读一小段</li>
<li>如果应用没有并行访问多个对象，RADOS 本身不会帮你并行</li>
<li>每个对象落到单一 OSD 上，不会条带化</li>
</ol>
</li>
</ul>
<p>因此，<strong>如果应用不显式多线程并行读写</strong>，性能不会线性扩展。</p>
<hr>
<p><strong>2. Lustre：文件 → 条带化 → OST → OSS</strong></p>
<p>Lustre 的核心是 <strong>条带化（striping）</strong>：</p>
<ul>
<li>写文件时，Lustre 会把文件切成固定大小的<strong>条带（stripe）</strong>，每个条带交错分布到不同的 OST（Object Storage Target）。</li>
<li>与 Ceph 最大不同：
<ul>
<li><strong>同一个文件的单个大对象可以跨 OST 条带化</strong></li>
<li>客户端访问一个大文件时，<strong>Lustre 会自动并行调度多个 OST</strong></li>
<li>不需要应用层显式并行</li>
</ul>
</li>
</ul>
<p><strong>例子</strong><br>
同样是 1TB 文件：</p>
<ul>
<li>条带大小 1MB，条带数 8</li>
<li>意味着 <strong>第 1MB → OST1，下一条 1MB → OST2，依次循环</strong></li>
<li>如果有 100 个 OSS/OST，客户端可以一次并行打开 100 条 TCP 连接同时拉数据 → 性能近似线性扩展</li>
</ul>
<p><strong>3. Ceph vs Lustre 的关键区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比点</strong></th>
<th><strong>Ceph</strong></th>
<th><strong>Lustre</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据分布</strong></td>
<td>文件 → 对象 → PG → OSD</td>
<td>文件 → 条带 → OST</td>
</tr>
<tr>
<td><strong>单对象并行</strong></td>
<td><strong>不支持</strong>，一个对象只落一个 OSD</td>
<td><strong>支持</strong>，单文件的条带跨多个 OST</td>
</tr>
<tr>
<td><strong>并行度</strong></td>
<td>= 文件对象数 / 应用线程数</td>
<td>= 条带数 × OSS 数量</td>
</tr>
<tr>
<td><strong>客户端自动并行</strong></td>
<td>不会，应用需显式多线程</td>
<td>Lustre 客户端自动并行</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>大量小对象存储、云存储、虚拟化盘</td>
<td>HPC、大文件高吞吐</td>
</tr>
</tbody>
</table>
<p>总结一句话：</p>
<blockquote>
<p><strong>Ceph 的并行度是“对象级”的，而 Lustre 的并行度是“条带级”的</strong><br>
如果应用本身是顺序访问，Ceph 并行度低，而 Lustre 即使单线程也能自动并行调度。</p>
</blockquote>
<blockquote>
<p>“Ceph 一个文件多个对象，多个对象落在不同 PG 组里，这不是并行吗？”</p>
</blockquote>
<ul>
<li>
<p><strong>如果应用同时读写多个对象</strong> → 是并行的</p>
</li>
<li>
<p><strong>但默认情况下，客户端顺序读写一个文件</strong> → 只会操作一个对象 → 并行度低</p>
</li>
<li>
<p>Lustre 不需要应用做多线程 → 天生条带化 → <strong>自动高并发</strong></p>
</li>
</ul>
<h4 id="疑问-ceph-对象和-条带化关系">疑问： ceph 对象和 **条带化关系？</h4>
<p>关键点在于 <strong>Ceph 的对象切分</strong> 和 <strong>条带化（striping）</strong> 是两回事，但它们又能叠加在一起。<br>
我们一步一步拆开来看，并举例对比 <strong>不开启 striping</strong> 和 <strong>开启 striping</strong> 的差异。</p>
<hr>
<p><strong>1. Ceph 默认的对象切分（Object Splitting）</strong></p>
<p>在 Ceph 中，每个 RADOS 存储池（pool）会有一个 <strong>对象大小上限</strong>（通常是 4MB 或 8MB，默认 4MB）。<br>
当你写入一个大文件，比如 <strong>1GB</strong>，Ceph 会自动把它切分成多个 <strong>对象（Object）</strong>：</p>
<ul>
<li>
<p>假设对象大小是 <strong>4MB</strong></p>
</li>
<li>
<p><strong>1GB 文件 → 256 个对象</strong></p>
</li>
<li>
<p>每个对象通过 CRUSH 算法映射到 <strong>PG（Placement Group）</strong>，再由 PG 映射到具体的 <strong>OSD</strong>。</p>
</li>
</ul>
<p>🔹 <strong>效果</strong>：</p>
<ul>
<li>
<p>不用任何条带化配置，你就已经有了 <strong>多对象、多 OSD 并行</strong>。</p>
</li>
<li>
<p>但注意：<strong>同一个对象</strong>还是只在 <strong>一个 OSD</strong> 上，不会跨 OSD 并行。</p>
</li>
</ul>
<hr>
<p><strong>2. 开启条带化（Striping）</strong></p>
<p>条带化是 <strong>在对象内部</strong>再切片，目的是让<strong>单个大对象</strong>的内容跨 OSD 分布，从而进一步提升并行读写性能。</p>
<p>它由 <strong>librados</strong> 和 <strong>CephFS / RBD</strong> 提供，核心配置有两个参数：</p>
<ul>
<li>
<p><strong>stripe_unit（条带大小）</strong>：一次写入的最小块，比如 1MB。</p>
</li>
<li>
<p><strong>stripe_count（条带数）</strong>：每轮写入几个条带，比如 8。</p>
</li>
</ul>
<p><strong>2.1 举例：不开启 striping</strong></p>
<p>假设：</p>
<ul>
<li>
<p>对象大小：<strong>4MB</strong></p>
</li>
<li>
<p>文件大小：<strong>16MB</strong></p>
</li>
<li>
<p>共有 <strong>4 个 OSD</strong></p>
</li>
</ul>
<h4 id="写入逻辑"><strong>写入逻辑</strong>：</h4>
<ul>
<li>Ceph 把 16MB 文件切成 <strong>4 个对象</strong>，每对象 4MB。</li>
<li>这 4 个对象被 CRUSH 分布到 4 个 OSD（假设每个 OSD 恰好得到一个对象）。</li>
</ul>
<p>📌 <strong>写 4MB 对象时</strong>，只能走 <strong>单 OSD 单线程</strong>，无并行。<br>
并行度 = <strong>对象数量</strong>，与 <strong>对象大小</strong>强相关。</p>
<p>开启 striping**</p>
<p>假设：</p>
<ul>
<li><strong>stripe_unit = 1MB</strong></li>
<li><strong>stripe_count = 8</strong></li>
<li>对象大小 = stripe_unit × stripe_count = <strong>8MB</strong></li>
</ul>
<h4 id="写入逻辑-1"><strong>写入逻辑</strong>：</h4>
<ol>
<li>
<p>16MB 文件会切为 2 个对象，每个对象 8MB。</p>
</li>
<li>
<p><strong>对象内部</strong>再分成条带：每个对象 8MB → <strong>8 个 1MB 条带</strong>。</p>
</li>
<li>
<p>这 8 个条带轮流落在 <strong>8 个不同的 OSD</strong> 上（只要 CRUSH 足够分散）。</p>
</li>
</ol>
<p>📌 <strong>优势</strong>：</p>
<ul>
<li><strong>即使是一个对象</strong>，也能利用多个 OSD 同时写。</li>
<li>并行度 = <strong>对象数 × 条带数</strong>，显著提升。</li>
</ul>
<hr>
<p><strong>3. 为什么条带化有用</strong></p>
<p>如果文件足够大，且对象大小设置得小（比如 4MB），不开启 striping 也能获得不错的并行度，因为会有很多对象。</p>
<p><strong>但如果场景是</strong>：</p>
<ul>
<li>大文件数少</li>
<li>对象大小很大（比如 128MB 或 256MB）</li>
<li>单对象读写很频繁</li>
</ul>
<p>这时不开启条带化，单对象性能会被<strong>单 OSD 限制</strong>，<strong>开启 striping</strong> 后则能并行。</p>
<hr>
<h4 id="5-总结对比"><strong>5. 总结对比</strong></h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>不开启 striping</strong></th>
<th><strong>开启 striping</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>大文件切分</td>
<td>按 <strong>对象大小</strong>切</td>
<td>先按对象切，再对象内部切条带</td>
</tr>
<tr>
<td>单对象落点</td>
<td>单个对象只在 <strong>1 个 OSD</strong></td>
<td>单对象内部跨 <strong>多个 OSD</strong></td>
</tr>
<tr>
<td>并行度</td>
<td>≈ 对象数量</td>
<td>≈ 对象数量 × 条带数</td>
</tr>
<tr>
<td>适用场景</td>
<td>小文件多、默认场景</td>
<td>大文件少、追求单文件高带宽</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>5回答你的疑问</strong></p>
<blockquote>
<p>“Ceph 一个文件多个对象，多个对象落在不同 PG → 这不是并行吗？”</p>
</blockquote>
<p>是并行，但<strong>并行度受限于对象数量</strong>。<br>
如果：</p>
<ul>
<li>文件大、对象数多 → 自动并行，striping 可有可无。</li>
<li>文件大、对象数少（比如对象 256MB）→ <strong>不开启 striping</strong> 会受限，</li>
<li><strong>开启 striping</strong> 可以在<strong>对象内部</strong>也做到并行，性能更好。</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否条带化</th>
<th>单对象大小</th>
<th>并行度</th>
<th>单文件读写速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认</td>
<td>否</td>
<td>4MB</td>
<td>1 OSD</td>
<td>~1× OSD 带宽</td>
</tr>
<tr>
<td>条带化</td>
<td>是</td>
<td>1MB</td>
<td>8 OSD</td>
<td>~8× OSD 带宽</td>
</tr>
</tbody>
</table>
<p>所以，<strong>条带化的意义</strong>是：</p>
<ul>
<li>
<p>让<strong>同一个大文件</strong>在对象层面并行</p>
</li>
<li>
<p>打破“单对象只能在单 OSD 上访问”的瓶颈</p>
</li>
<li>
<p>类似 Lustre 的 OST 条带分布，但是在 <strong>对象级别</strong> 而不是文件级</p>
</li>
</ul>
<h1 id="二-gpfs文件系统机型性能">二、 GPFS文件系统机型性能</h1>
<h2 id="21--性能数据汇总">2.1  性能数据汇总：</h2>
<table>
<thead>
<tr>
<th>​<strong>​机型​</strong>​</th>
<th>​<strong>​类型​</strong>​</th>
<th>​<strong>​厂商​</strong>​</th>
<th>​<strong>​文件系统​</strong>​</th>
<th>​<strong>​单节点聚合带宽​</strong>​</th>
<th>​<strong>​元数据OPS（估算）​</strong>​</th>
<th>​<strong>​关键配置​</strong>​</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​ESS 3500​</strong>​</td>
<td>全闪</td>
<td>IBM</td>
<td>GPFS</td>
<td>读：80 GB/s  <!-- raw HTML omitted -->写：52 GB/s</td>
<td>≥1.5M</td>
<td>双控双路，24×NVMe SSD</td>
</tr>
<tr>
<td>​<strong>​ESS 3500​</strong>​</td>
<td>混闪</td>
<td>IBM</td>
<td>GPFS</td>
<td>读：43.2 GB/s  <!-- raw HTML omitted -->写：29.7 GB/s</td>
<td>80K–120K</td>
<td>1×ESS 3500 + 4×4U102磁盘柜</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>IBM SSS 6000 是目前该系列中性能最高的型号</li>
</ul>
<p><img src="https://aijishu.com/img/bVcfVg" alt=""></p>
<p>SSS 6000</p>
<ul>
<li>
<p>每 Rack U 的性能：读带宽为 77.5GB/s（更接近 Weka），</p>
</li>
<li>
<p>写带宽 38.75GB/s（略微超过 DDN AI400X2T），读 IOPS 3,250 k 也算超过 Weka 了吧。</p>
</li>
</ul>
<h2 id="22--机型配置">2.2  机型配置</h2>
<p>​</p>
<h3 id="ibm-storage-scale-系统规格对比">IBM Storage Scale 系统规格对比</h3>
<p>来源：https://www.ibm.com/cn-zh/products/storage-scale-system</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>Storage Scale System 3500</th>
<th>Storage Scale System 6000</th>
</tr>
</thead>
<tbody>
<tr>
<td>尺寸</td>
<td>2U</td>
<td>4U</td>
</tr>
<tr>
<td>支持驱动器</td>
<td>24 × 30.72 TB TLC NVMe</td>
<td>24 × 61.44 TB QLC + 24 × 30.72 TB TLC NVMe 或 48 × 30.72 TB TLC NVMe 或 48 × 38.4 TB FCM</td>
</tr>
<tr>
<td>最大原始容量</td>
<td>737.28 TB</td>
<td>2,211.84 TB（混合 QLC + TLC）</td>
</tr>
<tr>
<td>最大吞吐量</td>
<td>126 GB/s</td>
<td>330 GB/s</td>
</tr>
<tr>
<td>扩展</td>
<td>多达 4 个直连 JBOD</td>
<td>多达 9 个直连 JBOD</td>
</tr>
<tr>
<td>数据传输接口</td>
<td>12 GB SAS</td>
<td>24 GB SAS</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="参数解读">参数解读</h3>
<ol>
<li><strong>尺寸 (U)</strong>
<ul>
<li>3500：2U，更紧凑，适合机房空间有限或中小规模部署</li>
<li>6000：4U，空间占用大，但提供更高性能和更大容量。</li>
</ul>
</li>
<li><strong>驱动器类型与配置</strong>
<ul>
<li>3500：全 NVMe（TLC），强调高性能随机 I/O。</li>
<li>6000：
<ul>
<li>可混合 QLC + TLC NVMe，提高容量同时兼顾部分性能。</li>
<li>可选 FlashCore Module（FCM），进一步提升闪存性能。</li>
<li>支持更多驱动器（48 个），容量与并行吞吐能力显著提升。</li>
</ul>
</li>
</ul>
</li>
<li><strong>最大原始容量</strong>
<ul>
<li>6000 的容量约为 3500 的 3 倍，可满足大规模数据存储需求。</li>
<li>混合 QLC + TLC 设计：成本和性能兼顾，TLC 提供高性能，QLC 提供高密度存储。</li>
</ul>
</li>
<li><strong>最大吞吐量</strong>
<ul>
<li>3500：126 GB/s，适合中等并行 I/O 场景。</li>
<li>6000：330 GB/s，高吞吐量，适合 HPC、大数据或 AI 训练场景。</li>
</ul>
</li>
<li><strong>扩展能力</strong>
<ul>
<li>3500：支持最多 4 个直连 JBOD（增加容量）。</li>
<li>6000：最多 9 个直连 JBOD，可横向扩展更大规模。</li>
</ul>
</li>
<li><strong>数据传输接口</strong>
<ul>
<li>3500：12 GB SAS，带宽受限于接口，适合中等负载。</li>
<li>6000：24 GB SAS，接口带宽翻倍，保证大规模并行 I/O 不受瓶颈。</li>
</ul>
</li>
</ol>
<hr>
<p>简单理解：</p>
<ul>
<li>
<p><strong>3500</strong>：紧凑、高性能，适合中小规模、高性能需求场景。</p>
</li>
<li>
<p><strong>6000</strong>：大容量、高吞吐量、可混合闪存，适合大规模集群、高并行 I/O 的 HPC/AI 数据中心。</p>
</li>
</ul>
<h2 id="23--ibm-spectrum-scalegpfs-架构">2.3  IBM Spectrum Scale(GPFS) 架构</h2>
<p><img src="https://s2.loli.net/2025/08/28/d9ArC74ZKVhR3MH.png" alt=""></p>
<h4 id="性能是架构设计的主要目标为什么支持并发访问"><strong>性能是架构设计的主要目标​</strong>，为什么支持并发访问</h4>
<p><strong>架构核心思想</strong>：并行化一切可以并行的操作，尽可能消除数据从应用到磁盘之间的等待。</p>
<h5 id="1-集群化管理-unified-management">1. 集群化管理 (Unified Management)</h5>
<ul>
<li><strong>设计要点</strong>：整个集群可以通过一个统一的界面（GUI）或者任意一个节点进行管理和操作。</li>
<li><strong>优势</strong>：提升了系统的可维护性和易用性，管理员无需登录特定主节点，降低了运维复杂度。</li>
</ul>
<h5 id="2-磁盘访问并行化-parallel-disk-access">2. 磁盘访问并行化 (Parallel Disk Access)</h5>
<ul>
<li><strong>设计要点</strong>：所有计算节点都能够<strong>直接并行地</strong>访问后端存储设备上的数据块或元数据。</li>
<li><strong>优势</strong>：打破了传统存储的中央网关瓶颈，实现了对存储带宽的线性扩展。存储设备越多，聚合带宽就越高。</li>
</ul>
<h5 id="3-数据-io-并行化-parallel-data-io">3. 数据 IO 并行化 (Parallel Data IO)</h5>
<ul>
<li><strong>设计要点</strong>：所有节点发出的数据或元数据读写请求可以同时进行处理。</li>
<li><strong>优势</strong>：极大地提升了系统的整体吞吐量（Throughput），能够同时响应海量客户端的请求。</li>
</ul>
<h3 id="什么架构设计支持高性能">什么架构设计支持高性能</h3>
<h4 id="1-节点角色清晰">1️⃣ 节点角色清晰</h4>
<table>
<thead>
<tr>
<th>节点</th>
<th>小白比喻</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计算节点</strong></td>
<td>工人</td>
<td>处理客户端请求，执行逻辑</td>
</tr>
<tr>
<td><strong>IO节点</strong></td>
<td>仓库管理员</td>
<td>读写文件和元数据</td>
</tr>
<tr>
<td><strong>存储节点（Disk/NSD）</strong></td>
<td>仓库</td>
<td>存放数据块</td>
</tr>
<tr>
<td><strong>管理节点</strong></td>
<td>厂长/调度员</td>
<td>管理集群、分配任务、控制一致性</td>
</tr>
</tbody>
</table>
<blockquote>
<p>分工明确 → 避免冲突 → 并发更高</p>
</blockquote>
<hr>
<h4 id="2-数据和元数据并行化">2️⃣ 数据和元数据并行化</h4>
<ul>
<li><strong>元数据</strong>：Metanode 管理文件信息，多人同时修改通过 Token 避免冲突</li>
<li><strong>数据</strong>：文件拆成小块，分布在不同磁盘，多节点可并行读写</li>
</ul>
<blockquote>
<p>比喻：订单表（元数据）+ 货物（数据），大家同时查表取货 → 整体效率高</p>
</blockquote>
<hr>
<h4 id="3-并发访问支持机制">3️⃣ 并发访问支持机制</h4>
<table>
<thead>
<tr>
<th>机制</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>分布式磁盘访问</strong></td>
<td>所有节点直接访问存储块，利用磁盘带宽</td>
</tr>
<tr>
<td><strong>并行数据 IO</strong></td>
<td>多个 IO 节点同时读写，提高吞吐量</td>
</tr>
<tr>
<td><strong>一致性控制（Token）</strong></td>
<td>多节点操作同一文件时保证一致性</td>
</tr>
<tr>
<td><strong>去中心化管理</strong></td>
<td>任意节点都能管理集群，消除中央瓶颈</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="疑问上面我没看懂-元数据怎么查找一个文件的">疑问：上面我没看懂 元数据怎么查找一个文件的</h3>
<h3 id="核心思想像查字典一样找文件">核心思想：像查字典一样找文件</h3>
<p>GPFS 管理文件元数据（如文件名、inode号）的核心思想是：​<strong>​将目录变成一个高效的“字典”​</strong>​，而不是一个“名单”。无论目录里有一个文件还是一百万个文件，它都能让你用接近恒定的速度找到目标。</p>
<p>目录 Inode：元数据的“总目录”</p>
<p>在 GPFS 中，​<strong>​每个目录本身也是一个特殊的文件​</strong>​（sparse file）。这个文件里存储的不是普通数据，而是该目录下所有文件和子目录的​<strong>​条目（entries）​</strong>​。</p>
<p>目录变大怎么办？—— “扩展附录”</p>
<p>当一个目录下的文件超过128个，4KB的“目录页”不够写了怎么办？</p>
<p>GPFS 的做法是：​<strong>​分配额外的存储块（Block）来存放多出来的条目​</strong>​，并在目录 inode 中通过​<strong>​间接指针（Indirect）​</strong>​ 来指向这些块。</p>
<p>这些被分配出来的块，专门用于存放元数据，因此被称为 ​<strong>​子元数据块（Sub Metablock）​</strong>​。每个 Sub Metablock 的大小是 8KB。</p>
<hr>
<h4 id="三如何快速查找-神奇的哈希算法">三、如何快速查找？—— “神奇的哈希算法”</h4>
<p>现在，目录的条目可能分散在多个 Sub Metablock 中。如何在上百万个条目中快速找到一个文件，而不用逐个扫描？GPFS 的答案是：​<strong>​可扩展哈希（Extendible Hashing）​</strong>​。</p>
<p>​<strong>​工作原理如下：​</strong>​</p>
<ol>
<li>
<p>​<strong>​计算哈希值​</strong>​：当你要查找一个文件（如 <code>myfile.txt</code>）时，GPFS 会先计算文件名的​<strong>​哈希值​</strong>​（一个数字指纹）。</p>
</li>
<li>
<p>​<strong>​定位块位置​</strong>​：系统会根据当前目录的大小，取这个哈希值最右边的 ​<strong>​n 个比特（bits）​</strong>​。这 n 个比特直接告诉系统，你要找的文件条目存放在​<strong>​第几个 Sub Metablock​</strong>​ 中。</p>
</li>
<li>
<p>​<strong>​直接访问​</strong>​：系统直接去那个确定的 Sub Metablock 里寻找，只需要扫描这个块内的条目即可。</p>
</li>
</ol>
<p>​<strong>​最精妙之处在于“可扩展”（动态扩容）：​</strong>​</p>
<ul>
<li>
<p>一开始目录是空的，n=1（只用1个bit，最多区分2个块：0和1）。</p>
</li>
<li>
<p>当某个 Sub Metablock 存满时，n 会变成 n+1（例如从1bit变成2bits）。</p>
</li>
<li>
<p>系统会​<strong>​新分配一个Sub Metablock​</strong>​，并将满的那个块中的条目​<strong>​一分为二​</strong>​，根据它们哈希值新增的那一位是0还是1，重新分配到老块或新块中。</p>
</li>
<li>
<p>这个过程就像书的内容变多了，附录从1卷扩展成2卷，并重新整理了一下目录的存放规则。</p>
</li>
</ul>
<h3 id="总结与优势">总结与优势</h3>
<p>通过这种设计，GPFS 的元数据管理实现了：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>实现方式</th>
<th>带来的优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​结构化存储​</strong>​</td>
<td>目录作为稀疏文件，使用 inode + Indirect块 + Sub Metablock</td>
<td>元数据存储清晰、可扩展</td>
</tr>
<tr>
<td>​<strong>​高速查找​</strong>​</td>
<td>​<strong>​可扩展哈希算法​</strong>​</td>
<td>​<strong>​查找速度恒定​</strong>​，不受目录大小影响（百万文件与千文件速度相当）</td>
</tr>
<tr>
<td>​<strong>​动态扩容​</strong>​</td>
<td>按需分配 Sub Metablock，哈希地址位动态扩展</td>
<td>扩容平滑，性能无抖动</td>
</tr>
</tbody>
</table>
<p>因此，GPFS 能够轻松应对​<strong>​超大规模、海量文件​</strong>​的场景（如AI训练、气象分析、基因测序），
这正是其作为顶级企业级文件系统的核心竞争力之一。</p>
<h2 id="疑问-如果目录大小发生了变化不是整个数据重新分配吗">疑问： 如果目录大小发生了变化，不是整个数据重新分配吗？</h2>
<h2 id="1-目录大小变化--数据重新分配">1️⃣ 目录大小变化 ≠ 数据重新分配</h2>
<ul>
<li>
<p>目录（Directory）只是<strong>指针数组</strong>，每个指针指向一个桶（Bucket）</p>
</li>
<li>
<p>目录翻倍时，<strong>只是复制指针</strong>，并没有移动桶里面的数据</p>
</li>
<li>
<p>桶的数据仍然在原来的物理位置</p>
</li>
</ul>
<blockquote>
<p>换句话说，目录扩容只是“让指针表更大”，而实际存储的数据不动</p>
</blockquote>
<hr>
<h2 id="2-案例理解">2️⃣ 案例理解</h2>
<p>假设全局深度 <code>d=2</code>，目录有 4 个指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">00 -&gt; 桶 A
01 -&gt; 桶 B
10 -&gt; 桶 B
11 -&gt; 桶 C
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>桶 B 满了，本地深度 <code>k = 2</code>（等于全局深度 d）</p>
</li>
<li>
<p>目录翻倍（d = 3）：</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">000 -&gt; 桶 A
001 -&gt; 桶 A
010 -&gt; 桶 B  （之前指针复制）
011 -&gt; 桶 B  （之前指针复制）
100 -&gt; 桶 B
101 -&gt; 桶 B
110 -&gt; 桶 C
111 -&gt; 桶 C
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>此时数据仍在原来的桶 B 里</strong></p>
</li>
<li>
<p>然后桶 B 执行分裂，部分数据移动到新桶 B2</p>
</li>
<li>
<p>其他桶（A、C）的数据完全不动</p>
</li>
</ul>
<blockquote>
<p>关键点：<strong>只有满的桶的数据才会移动</strong>，其余桶不受影响</p>
</blockquote>
<hr>
<h2 id="3-核心结论">3️⃣ 核心结论</h2>
<ol>
<li>
<p>目录扩容只影响指针表，不影响大部分桶的数据</p>
</li>
<li>
<p>桶满才会局部分裂 → 只移动该桶的数据</p>
</li>
<li>
<p>所以可扩展哈希可以在<strong>动态扩容时保持高效</strong>，避免整个表重新哈希</p>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://juicefs.com/zh-cn/blog/engineering/lustre-vs-juicefs#">https://juicefs.com/zh-cn/blog/engineering/lustre-vs-juicefs#</a> Lustre 与 JuiceFS ：架构设计、文件分布与特性比较</li>
<li><a href="http://lustrefs.cn/wp-content/uploads/2023/11/CLUG2023_03_%E9%99%88%E9%81%93%E7%A2%A7_DDN%E6%8C%81%E7%BB%AD%E6%94%AF%E6%8C%81Lustre%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B1%95.pdf">http://lustrefs.cn/wp-content/uploads/2023/11/CLUG2023_03_%E9%99%88%E9%81%93%E7%A2%A7_DDN%E6%8C%81%E7%BB%AD%E6%94%AF%E6%8C%81Lustre%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B1%95.pdf</a> DDN中国 陈道碧</li>
<li>AI 时代的高端文件存储系统：IBM、DDN、Weka 和 VAST <a href="https://aijishu.com/a/1060000000498772">https://aijishu.com/a/1060000000498772</a></li>
<li>【CMU15-445 FALL 2022】Project #1 - Extendable Hashing</li>
<li>CMU 15445 学习笔记—5 Hash Table</li>
<li>【数据库】可拓展哈希（Extendable Hashing）</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Troy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2024-08-07 00:00
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/nusr/blog/blob/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/interview/interviewSystemDesgin/2025/day21-system-desgin-small_1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">从零实现分布式文件系统(二) 如何在不升级硬件的前提下,小文件并发读写性能提升十倍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/interview/5-2025-05-14-3fs-ObjectPool/">
            <span class="next-text nav-default">从青铜到王者系列：一行代码解千愁：看DeepSeek-Ai/3FS对象池如何消除80%锁竞争</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="wangcy6/wangcy6.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wang_cyi@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/wangcy6" class="iconfont icon-github" title="github"></a>
  <a href="https://wangcy6.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Troy</span>
  </span>
</div>
<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138883536-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
