<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>面试官:为什么大厂拒绝使用shared_ptr（shared_ptr vs intrusive_ptr)? - Troy的网络博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Troy" /><meta name="description" content="do book" /><meta name="keywords" content="daily-interview-question, Github, c&#43;&#43;, Leetcode 题解, 后端面试" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://wangcy6.github.io/post/interview/c&#43;&#43;/day6_c&#43;&#43;_weely_2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="面试官:为什么大厂拒绝使用shared_ptr（shared_ptr vs intrusive_ptr)?" />
<meta property="og:description" content="do book" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangcy6.github.io/post/interview/c&#43;&#43;/day6_c&#43;&#43;_weely_2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2025-07-26T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2025-07-26T00:00:00&#43;00:00" />

<meta itemprop="name" content="面试官:为什么大厂拒绝使用shared_ptr（shared_ptr vs intrusive_ptr)?">
<meta itemprop="description" content="do book"><meta itemprop="datePublished" content="2025-07-26T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2025-07-26T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4572">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面试官:为什么大厂拒绝使用shared_ptr（shared_ptr vs intrusive_ptr)?"/>
<meta name="twitter:description" content="do book"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="https://github.com/wangcy6/weekly/tree/master/book">
        <li class="mobile-menu-item">阅读清单</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://github.com/wangcy6/weekly/tree/master/book">阅读清单</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">面试官:为什么大厂拒绝使用shared_ptr（shared_ptr vs intrusive_ptr)?</h1>

      <div class="post-meta">
        <span class="post-time"> 2025-07-26 00:00 </span>
        <div class="post-category">
            <a href="/categories/do-book/"> do book </a>
            </div>
          <span class="more-meta"> 约 4572 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#21--问题背景">2.1  问题背景</a>
      <ul>
        <li><a href="#1---性能问题原子引用计数过慢">1.   <strong>性能问题：原子引用计数过慢</strong></a></li>
        <li><a href="#2-内存碎片">2 内存碎片</a></li>
        <li><a href="#3-循环引用回调链释放不掉">3 循环引用：回调链释放不掉</a></li>
      </ul>
    </li>
    <li><a href="#22--解决办法">2.2  解决办法：</a>
      <ul>
        <li><a href="#boostintrusive_ptr">boost::intrusive_ptr</a></li>
        <li><a href="#222-举例说明">2.2.2 举例说明</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#oceanbase跨线程对象传递的完整解决方案">OceanBase 跨线程对象传递的完整解决方案</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#经典书籍">经典书籍</a></li>
      </ul>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>各位老师好（老师是山东对人的尊称，就像称呼帅哥美女一样）</p>
<p>C++周刊 （c++ weekly）第二期开始了</p>
<p><strong>本期预告</strong>：</p>
<ul>
<li>本期我们将深入理解shared_ptr</li>
<li>帮你破解大厂经典面试题智能指针使用场景</li>
<li>并解读它在开源项目具体实现。
<strong>周刊目标</strong>：</li>
<li>让你学到每个 c++知识，都关联一个经典面试，并对对应开源项目实践</li>
</ul>
<h1 id="一主题阅读c高频面试题">一、主题阅读:c++高频面试题</h1>
<table>
<thead>
<tr>
<th>序号</th>
<th>知识地图</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>新特性</td>
<td><a href="https://mp.weixin.qq.com/s/zBf1Dwp6e4wzXgRXJXrA5w?token=134003807&amp;lang=zh_CN">一分钟讲透:c++新特性string_view</a></td>
</tr>
<tr>
<td>2</td>
<td>库的编译链接</td>
<td><a href="https://mp.weixin.qq.com/s/AVlpGxdHK953l_wqVgTu4Q?token=134003807&amp;lang=zh_CN">如何给一个高速行驶的汽车换轮胎（实现一个可扩展c++服务）</a></td>
</tr>
<tr>
<td>3</td>
<td>STL</td>
<td><a href="https://mp.weixin.qq.com/s/6_oyn6aGUX8M0SmjlL8qWw">Traits 技术</a></td>
</tr>
<tr>
<td>4</td>
<td>新特性</td>
<td><a href="https://mp.weixin.qq.com/s/JAfX1o-_CWmLU_Yg5mne8Q">if constexpr</a><!-- raw HTML omitted --></td>
</tr>
<tr>
<td>5</td>
<td>新特性</td>
<td><a href="https://mp.weixin.qq.com/s/9HT9sOzf7Nq-qHIOGtjxSQ">面试题：C++中shared_ptr是线程安全的吗?</a></td>
</tr>
<tr>
<td>6</td>
<td>模板</td>
<td><a href="https://mp.weixin.qq.com/s/DwbLC8DYaR2AFzreQQv3CQ">C++17 新特性 std::optional</a></td>
</tr>
<tr>
<td>7</td>
<td>class</td>
<td><a href="https://mp.weixin.qq.com/s/HXmCFhUP73c7A6OyN10qZQ">c++类的成员函数，能作为线程的参数吗</a></td>
</tr>
<tr>
<td>8</td>
<td>编译器</td>
<td><a href="https://mp.weixin.qq.com/s/ZrAB-LUBtSvoknsn5vPfVQ?">const 如何保证const不变</a></td>
</tr>
<tr>
<td>9</td>
<td>值语义</td>
<td><a href="https://mp.weixin.qq.com/s/c1udiVd-0QPO2W9IyowoHg">一道面试题看深拷贝构造函数问题</a></td>
</tr>
<tr>
<td>10</td>
<td>值语义</td>
<td><a href="https://mp.weixin.qq.com/s/_-ZG4oMugRTlBnA0zm7g0g"> 智能指针究竟在考什么</a></td>
</tr>
<tr>
<td>11</td>
<td>指针</td>
<td><a href="https://mp.weixin.qq.com/s/pZdxMguvojG0iFRqDaI2Ig?">使用 C++ 智能指针遇到的坑</a></td>
</tr>
</tbody>
</table>
<h1 id="二ceph-为什么放弃大量使用-shared_ptr">二、Ceph 为什么放弃大量使用 shared_ptr</h1>
<table>
<thead>
<tr>
<th>阶段</th>
<th>特点</th>
<th>问题</th>
<th>优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>早期</td>
<td>大量使用 <code>shared_ptr</code> 捕获 <code>this</code></td>
<td>循环引用、内存泄漏</td>
<td>改成 <code>weak_ptr</code></td>
</tr>
<tr>
<td>中期</td>
<td><code>shared_ptr</code> 在百万 IOPS 下性能瓶颈</td>
<td>5~15% CPU 时间耗在原子操作上</td>
<td>引入 <code>intrusive_ptr</code></td>
</tr>
<tr>
<td>后期</td>
<td>进一步优化异步回调</td>
<td>异步 lambda 多层嵌套仍可能泄露</td>
<td>状态机 + 弱引用管理</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>模块</th>
<th>历史实现</th>
<th>问题表现</th>
<th>现状</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AsyncMessenger</strong></td>
<td>原始版大量 <code>std::shared_ptr&lt;Connection&gt;</code></td>
<td>回调闭包循环引用；锁竞争高</td>
<td><strong>全面迁移 intrusive_ptr</strong></td>
</tr>
<tr>
<td><strong>ObjectCacher</strong></td>
<td>老版本使用 <code>shared_ptr&lt;Object&gt;</code></td>
<td>高频拷贝带来 10% CPU overhead</td>
<td>新版部分改 intrusive_ptr，部分用裸指针</td>
</tr>
<tr>
<td><strong>BlueStore</strong></td>
<td><code>shared_ptr&lt;Buffer&gt;</code>、<code>shared_ptr&lt;Extent&gt;</code></td>
<td>buffer 分配 + 原子操作开销大</td>
<td>大量切 intrusive_ptr</td>
</tr>
<tr>
<td><strong>Objecter</strong></td>
<td>用 <code>shared_ptr&lt;Op&gt;</code> 追踪请求</td>
<td>回调泄漏问题明显</td>
<td>改 intrusive_ptr + 智能 weak 回调</td>
</tr>
<tr>
<td><strong>librados</strong></td>
<td>客户端 API 仍暴露 <code>shared_ptr</code></td>
<td>兼容性考虑</td>
<td><strong>对外 shared_ptr，内部 intrusive_ptr</strong></td>
</tr>
</tbody>
</table>
<h2 id="21--问题背景">2.1  问题背景</h2>
<p>Ceph 没有完全放弃 <code>shared_ptr</code>，但<strong>在核心路径上几乎全部替换成 <code>intrusive_ptr</code></strong>。【why】</p>
<p>在 Ceph 的设计中，
几乎所有核心模块（ObjectCacher、AsyncMessenger、BlueStore 等）
都会频繁创建和销毁对象【有什么影响】</p>
<p>在这种高并发、高 IOPS 的场景中，<code>shared_ptr</code> 的几个特性变成了性能瓶颈。</p>
<h3 id="1---性能问题原子引用计数过慢">1.   <strong>性能问题：原子引用计数过慢</strong></h3>
<p><code>shared_ptr</code> 内部维护一个 <strong>控制块</strong>，包含：</p>
<ul>
<li>对象指针</li>
<li>原子引用计数（strong + weak）</li>
<li>自定义 deleter</li>
</ul>
<p>在 Ceph 这种热点路径中，每次增减计数都触发 <strong>原子操作</strong> → <strong>CPU 开销非常高</strong>。[why]</p>
<p><strong>问题示例：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 模拟 Ceph 中曾经的代码
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">handle_op</span><span class="p">(</span><span class="n">OSDService</span><span class="o">&amp;</span> <span class="n">osd</span><span class="p">,</span> <span class="n">Message</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 创建请求对象：一次潜在的 make_shared 分配
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">OpRequest</span><span class="o">&gt;</span> <span class="n">op</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">OpRequest</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

    <span class="c1">// 2. 入队到某个工作队列：一次拷贝，原子 strong_ref++
</span><span class="c1"></span>    <span class="n">osd</span><span class="p">.</span><span class="n">get_op_queue</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

    <span class="c1">// 3. 工作线程从队列取出：又一次拷贝？原子 strong_ref++ 和 strong_ref--
</span><span class="c1"></span>    <span class="c1">// ... 在多个线程和函数调用中不断传递 ...
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>在一个100GB/s带宽、百万IOPS的集群中，假设每个IO请求在生命周期内平均经历10次 <code>shared_ptr</code>的拷贝/析构，那么每秒就会发生 ​<strong>​100万 * 10 = 1000万次​</strong>​ 原子操作。</p>
<p>Profiling 发现，仅仅是执行这些原子操作，就可能消耗掉 ​<strong>​5-15% 的总CPU时间​</strong>​。</p>
<p>这意味着CPU有超过十分之一的算力没有用于处理真正的数据</p>
<h5 id="来源-reddit">来源 ：reddit</h5>
<p>Slow assignment operations.  赋值操作缓慢</p>
<ul>
<li>Assigning to a <code>shared_ptr</code> requires a synchronized atomic operation, which is over 10 times slower than a raw pointer assignment.</li>
<li>对 <code>shared_ptr</code> 进行赋值需要同步原子操作，这比原始指针赋值慢 10 倍以上</li>
<li>The slowdown is even greater for highly concurrent code.</li>
<li>对于高并发代码，这种速度下降更为显著</li>
</ul>
<h4 id="来源-evaluating-the-cost-of-atomic-operations-on-modern-architectures">来源：# Evaluating the Cost of Atomic Operations on Modern Architectures</h4>
<ul>
<li>在测试的多个 Xeon、Ivy Bridge、Haswell 架构上，原子操作（如 CAS 和 Fetch-and-Add）都有很高的延迟，而且即使指令没有依赖关系，原子操作也会破坏指令级并行性。</li>
<li>这说明在高频场景下，每一次原子操作都可能成为性能瓶颈</li>
</ul>
<h3 id="2-内存碎片">2 内存碎片</h3>
<p>一个 <code>std::shared_ptr&lt;T&gt;</code>的生命周期需要至少两次内存分配（如果不使用 <code>make_shared</code>）：</p>
<ol>
<li><code>new T</code>：分配对象本身。</li>
<li>new control_block`：分配控制块（包含引用计数、弱计数、删除器等）。</li>
</ol>
<p>即使使用 <code>make_shared</code>优化，将两次分配合并为一次，
​<strong>​控制块和对象<code>T</code>仍然在内存上是紧邻的同一个内存块​</strong>​。这带来了新的问题：</p>
<ul>
<li>
<p>​<strong>​内存放大与碎片化：​</strong>​ 假设 <code>T</code>很小（比如一个几十字节的请求头），但控制块的大小是固定的（通常为几十字节）。这导致每个逻辑对象实际占用的内存远大于其数据本身，​<strong>​降低了内存使用效率​</strong>​。频繁创建和释放数百万个这样的混合块，会​<strong>​严重加剧内存碎片化​</strong>​。</p>
</li>
<li>
<p>​<strong>​缓存不友好（Cache Unfriendly）：​</strong>​ 这是更隐蔽的性能杀手。当代码访问 <code>T</code>的数据成员时，它会把整个内存块（包含控制块）加载到CPU缓存行（通常为64字节）中。</p>
</li>
</ul>
<h3 id="3-循环引用回调链释放不掉">3 循环引用：回调链释放不掉</h3>
<p>eph 在底层大量使用 <strong>事件驱动</strong> + <strong>异步回调</strong> 模型，特别是在网络通信、对象缓存、IO 路径上，比如：</p>
<ul>
<li><code>AsyncMessenger</code>：处理消息收发。</li>
<li>ObjectCacher`：管理对象缓存。</li>
<li><code>BlueStore</code>：底层存储引擎，所有读写异步完成后用回调通知上层</li>
<li>Ceph 大量使用异步回调模式，<code>shared_ptr</code> 捕获 <code>this</code> 导致循环引用。</li>
</ul>
<p>2018 年左右的 Ceph Luminous → Mimic 演进中引入，提交记录可以追溯到：</p>
<blockquote>
<p><strong>commit:</strong> ceph/ceph@4b6c9ef<br>
<strong>title:</strong> &ldquo;msg/async: avoid shared_ptr cycles by using weak_ptr in callbacks&rdquo;</p>
</blockquote>
<p>在 Ceph 的 <code>src/msg/async/AsyncMessenger.cc</code> 中，有大量异步消息收发和回调，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">AsyncConnection</span><span class="o">::</span><span class="n">start_connect</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">weak_self</span> <span class="o">=</span> <span class="n">weak_from_this</span><span class="p">();</span>
    <span class="c1">//auto self = shared_from_this();
</span><span class="c1"></span>    <span class="n">transport</span><span class="o">-&gt;</span><span class="n">async_connect</span><span class="p">([</span><span class="n">weak_self</span><span class="p">](</span><span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//transport-&gt;async_connect([self](int r)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">self</span> <span class="o">=</span> <span class="n">weak_self</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">self</span><span class="o">-&gt;</span><span class="n">handle_connect</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><p>过去 Ceph 在这块遇到的典型问题：</p>
<ul>
<li>
<p>当客户端关闭连接时，<code>AsyncConnection</code> 预期应该析构。</p>
</li>
<li>
<p>但由于 lambda 捕获了 <code>self</code>，直到回调触发前，这个对象都无法释放。</p>
</li>
<li>
<p>如果连接中断，回调可能永远不会触发，造成<strong>内存泄漏</strong>。</p>
</li>
</ul>
<p>**解决办法：弱引用 （这个办法不好，上来无法判断是否产生循环）</p>
<h2 id="22--解决办法">2.2  解决办法：</h2>
<p>intrusive_ptr 的核心思想</p>
<p>The <strong>intrusive_ptr</strong> class template stores a pointer to an object with an embedded reference count</p>
<p><code>intrusive_ptr</code> 来自 Boost，但 Ceph 做了定制优化：</p>
<h3 id="boostintrusive_ptr">boost::intrusive_ptr</h3>
<ul>
<li>boost::intrusive_ptr一种“侵入式”的引用计数指针，它实际并不提供引用计数功能，</li>
<li>而是要求被存储的对象自己实现引用计数功能，</li>
<li>并提供intrusive_ptr_add_ref和intrusive_ptr_release函数接口供boost::intrusive_ptr调用。</li>
<li>为什么 intrusive_ptr 没有进入标准库？</li>
<li>boost::intrusive_ptr为什么叫做倾入指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">
<span class="cp">#include</span> <span class="cpf">&lt;boost/intrusive_ptr.hpp&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;intrusive_ptr_base.hpp&#34;</span><span class="cp">
</span><span class="cp"></span>

<span class="err">用户类类型继承自</span><span class="n">intrusive_ptr_base</span><span class="err">，</span>
<span class="err">该实现方式类似于</span><span class="n">boost</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="err">`</span>


<span class="n">class</span> <span class="nl">Connection</span> <span class="p">:</span> <span class="n">public</span> <span class="n">intrusive_ptr_base</span><span class="o">&lt;</span> <span class="n">Connection</span> <span class="o">&gt;</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>特性</th>
<th><code>intrusive_ptr</code></th>
<th><code>std::shared_ptr</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​内存开销​</strong>​</td>
<td>​<strong>​一次分配​</strong>​。计数器在对象内部，无额外控制块。</td>
<td>​<strong>​两次分配​</strong>​（或一次合并分配）。有外部控制块开销。</td>
</tr>
<tr>
<td>​<strong>​内存布局​</strong>​</td>
<td>​<strong>​缓存友好​</strong>​。对象和计数器在一起，常在同一缓存行。</td>
<td>​<strong>​可能缓存不友好​</strong>​。对象和控制块可能分离。</td>
</tr>
<tr>
<td>​<strong>​性能​</strong>​</td>
<td>​<strong>​稍高​</strong>​。无额外分配，缓存局部性更好。但原子操作开销仍在。</td>
<td>​<strong>​稍低​</strong>​。有分配开销，可能缓存不友好。</td>
</tr>
<tr>
<td>​<strong>​侵入性​</strong>​</td>
<td>​<strong>​是​</strong>​。必须修改类定义，添加计数器和友元函数。</td>
<td>​<strong>​否​</strong>​。无需修改类即可使用，是非侵入式的。</td>
</tr>
<tr>
<td>​<strong>​易用性​</strong>​</td>
<td>​<strong>​复杂​</strong>​。需要手动实现引用计数逻辑，容易出错。</td>
<td>​<strong>​简单​</strong>​。开箱即用，自动化程度高。</td>
</tr>
<tr>
<td>​<strong>​适用场景​</strong>​</td>
<td>1. ​<strong>​极致性能优化​</strong>​（如Ceph）。  <!-- raw HTML omitted -->2. 需要与​<strong>​已有内置引用计数​</strong>​的C结构体交互。  <!-- raw HTML omitted -->3. 需要​<strong>​与<code>shared_ptr</code>共享所有权​</strong>​（但不能直接转换）。</td>
<td>​<strong>​绝大多数通用场景​</strong>​。安全、方便，是默认首选。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>shared_ptr</code>（标准库）</th>
<th><code>intrusive_ptr</code>（Ceph）</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用计数存储位置</td>
<td><strong>堆外</strong>，独立 control block</td>
<td><strong>对象内嵌</strong>在类中</td>
</tr>
<tr>
<td>原子操作</td>
<td>每次拷贝/析构都原子</td>
<td><strong>可选</strong>，局部无锁优化</td>
</tr>
<tr>
<td>生命周期管理</td>
<td>自动</td>
<td>自动</td>
</tr>
<tr>
<td>内存占用</td>
<td>需要额外分配 control block</td>
<td>零额外分配</td>
</tr>
<tr>
<td>循环引用</td>
<td>容易发生</td>
<td>Ceph 通过弱引用 + 显式解环</td>
</tr>
<tr>
<td>性能</td>
<td>高并发下性能瓶颈</td>
<td>Ceph 实测降低 <strong>5~10% CPU 消耗</strong></td>
</tr>
</tbody>
</table>
<p>核心优化点：</p>
<ul>
<li>
<p><strong>引用计数内嵌</strong> → 少一次内存分配</p>
</li>
<li>
<p><strong>原子操作可控</strong> → 大部分情况下局部无锁</p>
</li>
<li>
<p><strong>更容易做 weak_ptr</strong> → 避免循环引用</p>
</li>
</ul>
<h3 id="222-举例说明">2.2.2 举例说明</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// src/msg/async/AsyncConnection.h
</span><span class="c1"></span><span class="n">class</span> <span class="nl">AsyncConnection</span> <span class="p">:</span> <span class="n">public</span> <span class="n">RefCountedObject</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">RefCountedObject</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nref</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="nl">public</span><span class="p">:</span>
  <span class="kt">void</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="n">nref</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">put</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nref</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">delete</span> <span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><p>然后 <code>intrusive_ptr</code> 会这样调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">intrusive_ptr_add_ref</span><span class="p">(</span><span class="n">RefCountedObject</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">intrusive_ptr_release</span><span class="p">(</span><span class="n">RefCountedObject</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">();</span>
<span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><h1 id="三oceanbase禁用智能指针">三、oceanbase禁用智能指针</h1>
<p>不允许使用智能指针，允许通过 <code>Guard</code> 类自动释放资源。</p>
<p>boost 库支持智能指针，包括 <code>scoped_ptr</code>、<code>shared_ptr</code> 以及 <code>auto_ptr</code>。</p>
<p>很多人认为智能指针能够被安全使用，尤其是 <code>scoped_ptr</code>，</p>
<p>不过 OceanBase 已有代码大多都手动释放资源，且智能指针用得不好容易有副作用，</p>
<p>因此，不允许使用智能指针。</p>
<p>OceanBase 禁止智能指针​<strong>​不是倒退，而是一种在特定领域（高性能基础软件）下的高级工程权衡​</strong>​。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>std::shared_ptr</th>
<th>OceanBase方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用计数</td>
<td>原子操作，开销大</td>
<td>轻量级原子操作</td>
</tr>
<tr>
<td>内存布局</td>
<td>控制块和数据分离</td>
<td>可合并分配</td>
</tr>
<tr>
<td>跨线程传递</td>
<td>依赖原子操作</td>
<td>消息队列 + 引用计数</td>
</tr>
<tr>
<td>任务调度</td>
<td>无内置支持</td>
<td>内置线程池 + 任务队列</td>
</tr>
<tr>
<td>缓存友好性</td>
<td>差</td>
<td>好</td>
</tr>
<tr>
<td>内存分配</td>
<td>2次</td>
<td>1次（合并分配）</td>
</tr>
</tbody>
</table>
<h2 id="oceanbase跨线程对象传递的完整解决方案">OceanBase 跨线程对象传递的完整解决方案</h2>
<ul>
<li>
<p>明确所有权管理 - 使用 ObSharedGuard 替代 shared_ptr，提供更精确的控制</p>
</li>
<li>
<p>自定义引用计数 - 轻量级原子操作，避免 std::shared_ptr 的开销</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">ControlBlock</span> <span class="p">{</span>
  <span class="c1">// 使用轻量级原子操作
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">inc_weak_and_shared</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ATOMIC_INC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">weak_count_</span><span class="p">);</span>
    <span class="n">ATOMIC_INC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared_count_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">int64_t</span> <span class="nf">dec_shared</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ATOMIC_AAF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared_count_</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="c1">// 数据字段
</span><span class="c1"></span>  <span class="kt">int64_t</span> <span class="n">weak_count_</span><span class="p">;</span>      <span class="c1">// 弱引用计数
</span><span class="c1"></span>  <span class="kt">int64_t</span> <span class="n">shared_count_</span><span class="p">;</span>    <span class="c1">// 强引用计数
</span><span class="c1"></span>  <span class="n">ObFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">deleter_</span><span class="p">;</span>  <span class="c1">// 自定义删除器
</span><span class="c1"></span><span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>消息队列/Actor模型 - 线程池 + 任务队列，实现线程间的安全通信</li>
</ul>
<p>class ObOccamThreadPool</p>
<h1 id="三总结">三、总结：</h1>
<p><img src="https://s2.loli.net/2025/08/22/mljf1C5TEsWceRZ.png" alt=""></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>shared_ptr</code></th>
<th><code>intrusive_ptr</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>引用计数位置</strong></td>
<td>独立控制块</td>
<td>对象内部</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>原子操作，线程安全</td>
<td>默认非线程安全</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>控制块额外开销</td>
<td>无额外开销</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>原子操作略慢</td>
<td>高性能，需手动管理线程安全</td>
</tr>
<tr>
<td><strong>使用复杂度</strong></td>
<td>低，直接使用 <code>make_shared</code></td>
<td>高，需要对象实现 <code>add_ref/release</code></td>
</tr>
<tr>
<td><strong>循环引用风险</strong></td>
<td>可能，需要 <code>weak_ptr</code></td>
<td>可能，需要手动管理</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>普通 C++ 项目，多线程共享</td>
<td>高性能库/缓存对象（如 Ceph）</td>
</tr>
</tbody>
</table>
<p>最后 如何保证线程安全</p>
<ul>
<li>
<p><strong>与 <code>shared_ptr</code> 对比</strong></p>
<ul>
<li>
<p><code>shared_ptr</code> 内部引用计数是 <strong>原子操作</strong>，在多个线程中复制、销毁智能指针是安全的。</p>
</li>
<li>
<p><code>intrusive_ptr</code> 需要你自己保证在多线程访问时加锁或使用原子计数。</p>
</li>
</ul>
</li>
<li>
<p><strong>实际使用方式</strong></p>
<ul>
<li>
<p><strong>单线程场景</strong>：直接使用 <code>intrusive_ptr</code> 就安全。</p>
</li>
<li>
<p><strong>多线程场景</strong>：</p>
<ul>
<li>
<p>可以把 <code>refcount</code> 定义成 <code>std::atomic&lt;int&gt;</code>，或者</p>
</li>
<li>
<p>在外部加锁管理对象生命周期。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经典书籍">经典书籍</h3>
<ul>
<li>
<p>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14
<img src="https://mmbiz.qpic.cn/mmbiz_png/DMCnyCrhia34HFwVzjHLQiagdjxDfUBwmVJDbWX4hkrjMW3yGpjfoHoXIInLic2OlN9z9rGU1iaAribJKbZumts2lQw/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
</li>
<li>
<p>C++20 模板元编程</p>
</li>
</ul>
<p><img src="https://img3.doubanio.com/view/subject/l/public/s35197992.jpg" alt="">
推荐语：
玄之又玄，众妙之门</p>
<p>什么是玄而又玄呢？传统的解释有很多种，对多数程序员来说，都不大好理解。</p>
<p>在我看来，玄就是抽象。玄之又玄，就是抽象了再抽象。 (Ai目前还做不到)</p>
<p>人类的大脑喜欢生动具体的东西，比如小孩子都喜欢听故事，
无论是“小马过河” 还是“后羿射日”都有具体的场景、“人”和物。
长大了以后喜欢刷剧也是类似的原因。
每部剧都在一个具体的时空中讲一个故事。没有哪部剧没有人物，只有“道可道，非 常道”。</p>
<p>因此，做抽象是很难的事情。也因此，很多代码都是不够抽象的，</p>
<ul>
<li>今天需要 int 类 型的 max()函数，那么就写个int 类型的；</li>
<li>明天需要float 类型的，就把int 类型的复制一 份，改成float 类型的。</li>
<li>日积月累，整个项目里就有很多长相类似的代码了。</li>
<li>如何提炼这样的代码，消除重复，把它们合众为一呢？</li>
<li>传统C++中的模板技术就是为解决这个问题而设计的，现代C++将其发扬光大，去 除约束，增加功能，使其成为现代C++语言的一大亮点。</li>
<li>对于希望深入掌握C++的开发者而言，理解模板是进阶C++编程的必经之路。从泛 型编程(Generic Programming)、模板元编程(Template Metaprogramming)，到C++20 概 念(Concepts)，这些技术都在现代C++开发中占据了重要地位。</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://csguide.cn/cpp/memory/shared_ptr.html">https://csguide.cn/cpp/memory/shared_ptr.html</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/1bo6boj/stdshared_ptr_is_poor_gc_c_shouldnt_be_poor/">https://www.reddit.com/r/cpp/comments/1bo6boj/stdshared_ptr_is_poor_gc_c_shouldnt_be_poor/</a></li>
<li><a href="https://stackoverflow.com/questions/2139266/avoiding-indirect-cyclic-references-when-using-shared-ptr-and-weak-ptr">https://stackoverflow.com/questions/2139266/avoiding-indirect-cyclic-references-when-using-shared-ptr-and-weak-ptr</a></li>
<li><a href="https://www.boost.org/doc/libs/1_89_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr">https://www.boost.org/doc/libs/1_89_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Troy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2025-07-26 00:00
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/nusr/blog/blob/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/interview/c&#43;&#43;/day5-port-1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">大厂面试题：如果判断一个服务是否可用</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/interview/c&#43;&#43;/day7_c&#43;&#43;_weely_3/">
            <span class="next-text nav-default">面试官:指针和应用区别</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="wangcy6/wangcy6.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wang_cyi@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/wangcy6" class="iconfont icon-github" title="github"></a>
  <a href="https://wangcy6.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Troy</span>
  </span>
</div>
<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138883536-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
