<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Ceph分布式锁的设计哲学与工程实践 - Troy的网络博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Troy" /><meta name="description" content="do book" /><meta name="keywords" content="daily-interview-question, Github, c&#43;&#43;, Leetcode 题解, 后端面试" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://wangcy6.github.io/post/interview/2025-4-26_ceph/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Ceph分布式锁的设计哲学与工程实践" />
<meta property="og:description" content="do book" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangcy6.github.io/post/interview/2025-4-26_ceph/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-08-07T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-08-07T00:00:00&#43;00:00" />

<meta itemprop="name" content="Ceph分布式锁的设计哲学与工程实践">
<meta itemprop="description" content="do book"><meta itemprop="datePublished" content="2024-08-07T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2024-08-07T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="7699">
<meta itemprop="keywords" content="LINUX系统调用," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ceph分布式锁的设计哲学与工程实践"/>
<meta name="twitter:description" content="do book"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="https://github.com/wangcy6/weekly/tree/master/book">
        <li class="mobile-menu-item">阅读清单</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://github.com/wangcy6/weekly/tree/master/book">阅读清单</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Ceph分布式锁的设计哲学与工程实践</h1>

      <div class="post-meta">
        <span class="post-time"> 2024-08-07 00:00 </span>
        <div class="post-category">
            <a href="/categories/do-book/"> do book </a>
            </div>
          <span class="more-meta"> 约 7699 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#一这个技术出现的背景初衷和要达到什么样的目标或是要解决什么样的问题">一、这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题</a></li>
        <li><a href="#11-ceph-解决横向扩展问题单节点mds读写平均1千qps扩展128节点读写在10-万次秒">1.1 Ceph 解决横向扩展问题，单节点MDS读写平均1千QPS，扩展128节点读写在<strong>10 万次/秒</strong>。</a></li>
        <li><a href="#12--横向扩展的后果多客户端并发修改同一文件-怎么办">1.2  横向扩展的后果：多客户端并发修改同一文件 怎么办？</a></li>
        <li><a href="#二这个技术的优势和劣势分别是什么">二、这个技术的优势和劣势分别是什么</a></li>
        <li><a href="#21-分布式锁-优点">2.1 分布式锁 优点</a></li>
        <li><a href="#22-分布式锁缺点是什么">2.2 分布式锁缺点是什么</a></li>
        <li><a href="#三这个技术适用的场景任何技术都有其适用的场景离开了这个场景">三、这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景</a></li>
        <li><a href="#四技术的组成部分和关键点">四、技术的组成部分和关键点。</a></li>
        <li><a href="#41-修改不同的元数据采用不同的锁">4.1 修改不同的元数据，采用不同的锁</a></li>
        <li><a href="#42--无论何种类型的锁都有一个state变量记录当前锁的状态每个锁都有相关的状态机控制状态转移">4.2  无论何种类型的锁，都有一个state变量记录当前锁的状态。每个锁都有相关的状态机控制状态转移。</a></li>
        <li><a href="#scatterlock分散锁-的状态">ScatterLock：分散锁 的状态</a></li>
        <li><a href="#五技术的底层原理和关键实现">五、技术的底层原理和关键实现</a></li>
        <li><a href="#51--锁需要持久化吗">5.1  锁需要持久化吗？</a></li>
        <li><a href="#52-为什么是自驱">5.2 为什么是自驱</a></li>
        <li><a href="#六已有的实现和它之间的对比">六、已有的实现和它之间的对比</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>坚持思考，就会很酷。</p>
<p>大家好，这是<!-- raw HTML omitted -->进入大厂面试准备 第2篇文章<!-- raw HTML omitted -->，</p>
<p>”走暗路、耕瘦田、进窄门、见微光”  告诉我  面试关键就 项目 这个才是最考察基本功的地方。</p>
<ul>
<li>知识地图：数据一致性&mdash;分布式锁</li>
</ul>
<p>阅读本文你获得如何收益</p>
<h5 id="-在存储领域分布式锁解决什么问题">✅ 在存储领域，分布式锁解决什么问题？</h5>
<ul>
<li>分布式扮演协调者角色，协调客户端并发写入，协调多副本数据同步，甚至故障后恢复。</li>
<li>支持 多读，多写，互斥三个等场景</li>
</ul>
<h5 id="-分布式锁-怎么实现的">✅ 分布式锁 怎么实现的？</h5>
<ul>
<li>锁机制 基于状态机设计的，内部能自我驱动改变，业务无需过多干预。</li>
<li>每个状态实现融入Ceph原有业务流程中。很难单独剥离出来。</li>
<li>锁本身设计确实十分简洁，锁类型 ，锁状态，锁类型不支持相互转换，锁状态可以相互转换，通过锁评估完成自动转换。
✅  具体怎么实现的？</li>
<li>预告：锁状态变化变成元数据，持久化到存储层，后面重点存研究BlueStore存储引起</li>
<li>预告：锁融入每个文件操作 ：mkdir ，open 过程中 后面重点存研究IO流程 。</li>
</ul>
<h3 id="一这个技术出现的背景初衷和要达到什么样的目标或是要解决什么样的问题">一、这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题</h3>
<h3 id="11-ceph-解决横向扩展问题单节点mds读写平均1千qps扩展128节点读写在10-万次秒">1.1 Ceph 解决横向扩展问题，单节点MDS读写平均1千QPS，扩展128节点读写在<strong>10 万次/秒</strong>。</h3>
<p>在传统分布式文件系统（GFS）中，元数据管理集<!-- raw HTML omitted -->集中存储<!-- raw HTML omitted -->，一旦元数据服务器故障也会导致整个文件系统不可用。</p>
<p><strong>画外音：为什么采用单Master存储</strong></p>
<ul>
<li>GPFS 用来存储大文件，<strong>大文件数量有限</strong>，能将这个文件系统元数据加载到内容，单Master没毛病，正好正面了单Master设计是可行的</li>
<li>GFS 直接使用了 Linux 服务上的普通文件作为基础存储层，并且选择了最简单的单 Master 设计。单 Master 让 GFS 的架构变得非常简单，<!-- raw HTML omitted -->通过对数据进行Checkpoints等也做到秒级切换。<!-- raw HTML omitted --> （怎么做到的，加载数据不消耗时间吗？）</li>
<li>文件元数据数据结构3部分</li>
</ul>
<ol>
<li>目录树：例如  /data/geektime/bigdata/gfs01</li>
<li>文件被拆分成了哪几个数据快 chunk（64M）</li>
<li><!-- raw HTML omitted -->数据快chunk 实际被存储在了哪些 chunkserver（存储节点）<!-- raw HTML omitted --></li>
<li>Ceph集群的推荐规模为10个存储节,GFS 规模上千个，
<img src="https://money-1256465252.cos.ap-beijing.myqcloud.com/mac/20250426111745.png" alt="集中存储"></li>
</ol>
<p><img src="https://money-1256465252.cos.ap-beijing.myqcloud.com/mac/20250426111926.png" alt="设计原则"></p>
<p>CephFS 的设计初衷就是要打破这一限制，通过将<!-- raw HTML omitted -->元数据与数据路径分离<!-- raw HTML omitted -->，
让客户端直接通过 CRUSH 算法访问 OSD 存储，
而由独立的 MDS 集群专注于元数据管理，
来源：Ceph: A Scalable, High-Performance Distributed File System
<img src="https://money-1256465252.cos.ap-beijing.myqcloud.com/mac/20250426113612.png" alt="图2：ceph mds元数据管理"></p>
<p>画外音：</p>
<ol>
<li>如图2：元数据MDS只存储目录树，<strong>不维护 文件与对象之间关系</strong>，客户端通过crush算法计算出来</li>
<li>Ceph 项目起源 于 2003 年 Sage 就读博士期间的研究课题（Lustre 环境中的可扩展问题）.</li>
</ol>
<ul>
<li>牺牲单节点性能，追求<strong>横向扩展能力</strong>（如 128 节点集群总吞吐超 10万 OPS，单节点1千OPS）。</li>
<li>专为海量元数据场景设计（如超算中心百万级文件创建）
<strong>极端场景验证</strong>
<ul>
<li><strong>并发创建文件（writefiles）</strong>：<br>
128 MDS 集群在 2 秒内完成 6.4 万客户端并发创建文件，<strong>写性能未显著低于读</strong>，表明架构设计有效均衡了读写负载。</li>
</ul>
</li>
</ul>
<h3 id="12--横向扩展的后果多客户端并发修改同一文件-怎么办">1.2  横向扩展的后果：多客户端并发修改同一文件 怎么办？</h3>
<p>​</p>
<p>在CephFS中，元数据（如文件/目录的权限、大小、路径结构等）由多个MDS节点共同管理。</p>
<p>以下场景会导致数据不一致或性能问题：</p>
<ul>
<li>​<strong>​并发写冲突​</strong>​：多个客户端同时修改同一文件或目录（例如同时删除和重命名），也可能MDS内部相互访问。</li>
<li>​<strong>​缓存不一致​</strong>​：不同MDS节点或客户端缓存了同一元数据的副本，修改后未及时同步，如何主副本数据达到一致，如果 没有达成一致，该如如何访问。</li>
<li>​<strong>​MDS故障恢复​</strong>​：某个MDS节点宕机后，如何恢复其未完成的元数据操作并保持一致性？</li>
</ul>
<p>通过上面描述 你猜测到 分布式锁是这样一个锁</p>
<p>扮演功能</p>
<ul>
<li>多个客户端直接有序访问</li>
<li>多个元数据直接 副本达成一致</li>
<li>故障后还能自动恢复</li>
<li>保持锁的特性</li>
<li>肯定不是互斥锁 这个只能单机。</li>
</ul>
<p>画外音：</p>
<ul>
<li>具体是什么实现的还不清楚，继续往下看。</li>
<li>一个锁 怎么扮演这么多功能复杂吗？</li>
</ul>
<h3 id="二这个技术的优势和劣势分别是什么">二、这个技术的优势和劣势分别是什么</h3>
<h3 id="21-分布式锁-优点">2.1 分布式锁 优点</h3>
<p>高度抽象，业务参与很少。</p>
<ul>
<li>​<strong>​系统自动驱动​</strong>​
<ul>
<li>​<strong>​场景​</strong>​：锁状态机根据条件（如权限变更、副本同步、租约超时）自动调整锁状态。</li>
</ul>
</li>
</ul>
<p>MDS中锁状态自动评估和变更由以下因素综合驱动：</p>
<ul>
<li>请求驱动：客户端请求如读、写、打开文件等操作会触发锁状态评估
Server::handle_client_readdir&ndash;&gt;mds-&gt;locker-&gt;eval</li>
<li>定期评估：定期检查锁状态以优化性能和资源利用
Locker::tick()&mdash;-&gt;eval_scatter_gathers();</li>
<li>客户端能力(Caps)变化
Locker::handle_client_caps &ndash;&gt;mark_updated_scatterlock</li>
</ul>
<h3 id="22-分布式锁缺点是什么">2.2 分布式锁缺点是什么</h3>
<h5 id="分布式锁运行在mds服务中看单个-mds性能"><strong>分布式锁运行在MDS服务中，看单个 MDS性能</strong></h5>
<p><img src="https://money-1256465252.cos.ap-beijing.myqcloud.com/mac/20250426112911.png" alt="来源：Ceph: A Scalable, High-Performance Distributed File System"></p>
<p>画外音：</p>
<ol>
<li>每个节点<!-- raw HTML omitted -->最大吞吐量为1-5千，这么弱我研究它干什么<!-- raw HTML omitted -->，CephFS Design Goals Infinitely scalable Avoid all Single Points Of Failure Self Managing</li>
<li>在CephFS目标就是无线扩展，避免单点。集群规模128节点 读写次/秒</li>
</ol>
<ul>
<li><strong>单 MDS 测试</strong>：
<ul>
<li>读/写元数据操作均稳定在约 <strong>1000 次/秒</strong>（受单节点 CPU 限制）。</li>
</ul>
</li>
<li><strong>扩展性测试</strong>：
<ul>
<li>128 个 MDS 集群读吞吐量达 <strong>12.8 万次/秒</strong>，写吞吐量 <strong>10 万次/秒</strong>，验证近线性扩展能力。（一般企业规模部署没这么大）</li>
</ul>
</li>
</ul>
<p>扩展思考：为什么单节点这么慢，读写差不多？</p>
<ul>
<li>Ceph分布式锁阅读和理解很费劲，是不是一个缺点，太抽象了，高度抽象</li>
</ul>
<h3 id="三这个技术适用的场景任何技术都有其适用的场景离开了这个场景">三、这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景</h3>
<p>ceph 分布式锁机制通过结合
&lt;font color=&quot;#245bdb&quot;RADOS 对象存储的锁持久化<!-- raw HTML omitted --></p>
<ul>
<li>MDS 内部的多种锁类别（如 LocalLock、SimpleLock、ScatterLock）及 capability 缓存回收，在</li>
<li>多 MDS、跨网络、高并发访问场景下提供强一致性与高吞吐，同时支持动态子树分区的水平扩展和 HA 切换</li>
</ul>
<p>这种设计特别适合包括高</p>
<ul>
<li>
<p><strong>大型并行计算 / 科研算力（HPC scratch）</strong><br>
在超算或科研集群里，成百上千个计算节点往往要并行创建、写入、读取同一个目录下的临时文件（scratch space）。CephFS 的分布式锁让这些节点可以安全地并发操作元数据，不会因冲突而卡住或错误。</p>
</li>
<li>
<p><strong>容器化平台的共享持久卷</strong><br>
在 Kubernetes 等容器平台中，多个 Pod 可能要同时挂载同一份文件系统卷（CSI 卷）来读写日志、配置或共享数据。Ceph 分布式锁保证每个容器对目录树和文件的元数据访问都按序执行，避免写冲突和数据不一致。</p>
</li>
</ul>
<h3 id="四技术的组成部分和关键点">四、技术的组成部分和关键点。</h3>
<p>参考：</p>
<ul>
<li><a href="https://docs.ceph.com/en/latest/dev/mds_internals/locking/">https://docs.ceph.com/en/latest/dev/mds_internals/locking/</a></li>
</ul>
<h3 id="41-修改不同的元数据采用不同的锁">4.1 修改不同的元数据，采用不同的锁</h3>
<p>目的：</p>
<blockquote>
<p>不同的元数据（inode 和 dentry 中的）在不同情况下的行为不同，MDS 会使用不同类型的锁</p>
</blockquote>
<p>锁类定义了处理分布式锁所需的相关锁类型的锁定行为。MDS 定义了4个锁类：</p>
<h5 id="locallock-本地锁">LocalLock 本地锁</h5>
<blockquote>
<p>Used for data that does not require distributed locking such as inode or dentry version information. Local locks are versioned locks.
定义：</p>
</blockquote>
<ol>
<li>
<p>用于不需要分布式锁定的数据，</p>
</li>
<li>
<p>本地锁是基于版本的锁。</p>
</li>
</ol>
<p>特点：</p>
<ul>
<li>仅需本地协调，适用于单个MDS（元数据服务器）内的元数据操作，避免跨节点通信开销</li>
<li>锁的资源
例如管理 ​<strong>​inode（索引节点）​</strong>​ 或 ​<strong>​dentry（目录项）​</strong>​ 的版本信息。
CEPH_LOCK_DVERSION - dentry版本锁
CEPH_LOCK_IVERSION - inode版本锁</li>
</ul>
<p>日常比喻：
这就像你个人笔记本上的修改记录。</p>
<ul>
<li>每次你修改笔记，你在修改记录页上记一笔</li>
<li>不需要告诉其他人你修改了记录</li>
<li>只在你的桌子上有效，不影响他人</li>
</ul>
<h5 id="simplelock简单锁-共享读排他写">simplelock：简单锁 共享读，排他写</h5>
<blockquote>
<p>SimpleLock  - Used for data that requires shared read and mutually exclusive write.
This lock class is also the base class for other lock classes and specifies most of the locking behaviour for implementing distributed locks.</p>
</blockquote>
<p>定义：</p>
<ol>
<li>用于需要共享读取和互斥写入的数据。</li>
<li>这种锁类也是其他锁类的基类，并为实现分布式锁指定了大部分锁定行为。</li>
</ol>
<p>特点：</p>
<ul>
<li>支持读共享/写互斥模式</li>
<li>支持跨MDS协作</li>
<li>影响范围</li>
</ul>
<p>CEPH_LOCK_DN - 目录项锁
CEPH_LOCK_IAUTH - inode权限锁
CEPH_LOCK_ILINK - 硬链接锁
CEPH_LOCK_IXATTR - 扩展属性锁
CEPH_LOCK_ISNAP - 快照锁
CEPH_LOCK_IFLOCK - 文件锁管理锁
CEPH_LOCK_IPOLICY - 策略锁</p>
<p>举例：
当多个客户端读取同一目录内容，但只有一个客户端进行写入时：</p>
<ol>
<li>多个客户端可获取目录的共享读锁</li>
<li>当需要创建/删除文件时，一个客户端需获取排他写锁</li>
<li><!-- raw HTML omitted -->写操作时，所有读锁必须先释放<!-- raw HTML omitted --></li>
</ol>
<p>日常比喻：这像是办公室的会议室预订表。</p>
<ul>
<li>只有一个人能修改预订记录(写)</li>
<li>多人可以同时查看预订表(读)</li>
<li><!-- raw HTML omitted -->要修改时，必须确保没人正在更改<!-- raw HTML omitted --></li>
</ul>
<p>SimpleLock和sm_state_t的关系是：</p>
<ol>
<li>
<p>定义与实现：sm_state_t定义锁行为，SimpleLock实现这些行为</p>
</li>
<li>
<p>数据与逻辑：sm_state_t包含状态数据，SimpleLock包含操作逻辑</p>
</li>
<li>
<p>配置与运行时：sm_state_t是静态配置，SimpleLock是运行时对象</p>
</li>
<li>
<p>通用与特化：不同锁类型使用不同的sm_state_t表，但共享SimpleLock代码</p>
</li>
</ol>
<p>这种设计模式让Ceph能够用相同的代码基础实现多种不同行为的锁，同时保持代码清晰和行为一致。</p>
<h5 id="scatterlock分散锁-共享读共享写">ScatterLock：分散锁 共享读，共享写</h5>
<blockquote>
<p>ScatterLock - Used for data that requires shared read and shared write.
Typical use is where an MDS can delegate some authority to other MDS replicas,
e.g., replica MDSs can satisfy read capabilities for clients.</p>
</blockquote>
<p>定义：</p>
<ol>
<li>用于需要共享读取和共享写入的数据。</li>
<li>典型用途是MDS可以将部分权限委托给其他MDS副本，
例如，副本MDS可以满足客户端的读取能力请求。</li>
</ol>
<p>特点：</p>
<ul>
<li>支持读共享/写共享模式</li>
<li>允许权限委托给副本MDS</li>
<li>适用于可分散访问的数据</li>
</ul>
<p>举例1 ：
当多个客户端同时操作不同目录项时：</p>
<ol>
<li>MDS可以将部分目录的写权限委托给副本MDS</li>
<li>客户端A通过主MDS修改文件1的大小</li>
<li>同时，客户端B可以通过副本MDS修改文件2的大小</li>
<li>两个操作可以并行执行，无需互相等待</li>
</ol>
<p>举例2</p>
<ul>
<li>文件删除操作，一个文件目录分散到不同非MDS节点，MDS分别同时删除。
常比喻：</li>
</ul>
<p>这像是管理多个部门的项目，每个部门可以独立更新自己负责的部分。</p>
<ul>
<li>整体项目有一个主管理员</li>
<li>但各部门可以被授权管理自己的子项目</li>
<li>减少了向主管理员请示的次数
具体锁说明：</li>
<li>INEST锁 - 控制目录统计信息(如文件数量)的更新</li>
<li>IDFT锁 - 控制目录如何被分片和管理</li>
</ul>
<h6 id="code">code</h6>
<p>ScatterLock是Ceph MDS中的一种特殊锁类型，允许数据的分散管理。它的核心特点是：</p>
<ul>
<li>支持读写共享操作</li>
<li>允许将权限委派给其他MDS</li>
<li>适用于可分割的元数据(如目录统计信息)</li>
</ul>
<p>class ScatterLock : public SimpleLock</p>
<h6 id="scatterlock应用示例目录统计信息inest">ScatterLock应用示例：目录统计信息(INEST)</h6>
<p>背景场景</p>
<p>假设有一个大型目录/data，包含上万个文件，由多个MDS和客户端共同访问：</p>
<ul>
<li>
<p>MDS0是目录的权威节点(auth)</p>
</li>
<li>
<p>MDS1和MDS2是副本节点</p>
</li>
<li>
<p>多个客户端在不同子目录创建/删除文件</p>
</li>
</ul>
<h5 id="filelock文件锁">filelock：文件锁</h5>
<p>定义：</p>
<ol>
<li>文件锁是管理文件数据访问权限的专用锁，</li>
<li>控制客户端对文件内容的读取和写入操作。</li>
</ol>
<p>它是一种更复杂的锁类型，结合了SimpleLock和ScatterLock的特性，专门处理文件I/O权限。</p>
<p>特点：</p>
<ul>
<li>支持多级缓存模式</li>
<li>管理客户端读写权限</li>
<li>控制数据一致性和缓存行为</li>
<li>支持多种锁定状态以优化性能</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">LockType</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">sm_t</span> <span class="o">*</span><span class="n">sm</span><span class="p">;</span>
  <span class="n">explicit</span> <span class="nf">LockType</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">CEPH_LOCK_DN</span><span class="p">:</span> <span class="c1">// 管理dentry
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_IAUTH</span><span class="p">:</span> <span class="c1">// 管理mod,uid,gid等信息
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_ILINK</span><span class="p">:</span> <span class="c1">// 管理link属性
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_IXATTR</span><span class="p">:</span> <span class="c1">// 管理扩展属性
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_ISNAP</span><span class="p">:</span> <span class="c1">// 管理快照信息
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_IFLOCK</span><span class="p">:</span> <span class="c1">// 文件锁相关
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_IPOLICY</span><span class="p">:</span> <span class="c1">// 管理layout、quota等信息
</span><span class="c1"></span>      <span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sm_simplelock</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">CEPH_LOCK_IDFT</span><span class="p">:</span> <span class="c1">// 管理分片信息
</span><span class="c1"></span>    <span class="k">case</span> <span class="nl">CEPH_LOCK_INEST</span><span class="p">:</span> <span class="c1">// 管理目录递归统计信息，如文件个数等
</span><span class="c1"></span>      <span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sm_scatterlock</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">CEPH_LOCK_IFILE</span><span class="p">:</span> <span class="c1">//对于目录则是管理本层目录的统计信息，对于普通文件则是管理文件大小等
</span><span class="c1"></span>      <span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sm_filelock</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">CEPH_LOCK_DVERSION</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">CEPH_LOCK_IVERSION</span><span class="p">:</span>
      <span class="n">sm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sm_locallock</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="n">sm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>



</code></pre></td></tr></table>
</div>
</div><h3 id="42--无论何种类型的锁都有一个state变量记录当前锁的状态每个锁都有相关的状态机控制状态转移">4.2  无论何种类型的锁，都有一个state变量记录当前锁的状态。每个锁都有相关的状态机控制状态转移。</h3>
<h3 id="scatterlock分散锁-的状态">ScatterLock：分散锁 的状态</h3>
<p>解决问题：多写
状态定义：（复杂跳过）
<img src="https://money-1256465252.cos.ap-beijing.myqcloud.com/mac/20250426174925.png" alt="scatterlock"></p>
<p>根据状态机可以确定：</p>
<ul>
<li>下一步锁的状态(next_state)</li>
<li>其他副本的状态</li>
<li>允许谁可读（can_read）、谁可加读锁（can_rdlock）、谁可加写（can_wrlock）、谁可以加排他锁（can_xlock）等。这里的谁被抽象成为ANY、AUTH、XCL等。</li>
</ul>
<ol>
<li>ANY指的任何拥有Object副本的MDS，</li>
<li>AUTH（authority）指的是被授权Object的MDS，</li>
<li>XCL指的是被授权Object的MDS或者排他执行的客户端。</li>
</ol>
<ul>
<li>对应的caps是什么，包括拥有Object副本的MDS的此时应该使用的caps（针对不同的角色也分为4种）</li>
</ul>
<p>复杂程度而言，可以根据<strong>sm_state_t</strong>结构体里面定义的条数判</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sm_state_t</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>         <span class="c1">// 0表示稳定状态，非0表示应转换到的下一个状态
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="n">loner</span><span class="p">;</span>       <span class="c1">// 是否支持单客户端模式（独占优化）
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">replica_state</span><span class="p">;</span> <span class="c1">// 副本MDS应该处于的状态
</span><span class="c1"></span>  
  <span class="kt">char</span> <span class="n">can_read</span><span class="p">;</span>    <span class="c1">// 谁可以读取内容：ANY=所有人，AUTH=权威MDS，XCL=独占客户端
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_read_projected</span><span class="p">;</span> <span class="c1">// 谁可以读取投影数据（尚未完全提交的数据）
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_rdlock</span><span class="p">;</span>  <span class="c1">// 谁可以获取读锁：表示共享访问权限
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_wrlock</span><span class="p">;</span>  <span class="c1">// 谁可以获取写锁：表示独占写入权限
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_force_wrlock</span><span class="p">;</span> <span class="c1">// 谁可以强制获取写锁（即使有冲突）
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_lease</span><span class="p">;</span>   <span class="c1">// 谁可以获取租约：允许客户端缓存元数据
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">can_xlock</span><span class="p">;</span>   <span class="c1">// 谁可以获取独占锁：完全限制任何其他访问
</span><span class="c1"></span>  
  <span class="kt">int</span> <span class="n">caps</span><span class="p">;</span>         <span class="c1">// 通用能力位掩码：定义了客户端可获得的能力
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">loner_caps</span><span class="p">;</span>   <span class="c1">// 单客户端模式下可授予的额外能力
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">xlocker_caps</span><span class="p">;</span> <span class="c1">// 持有独占锁时可授予的额外能力
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">replica_caps</span><span class="p">;</span> <span class="c1">// 副本MDS可授予客户端的能力
</span><span class="c1"></span><span class="p">};</span>


<span class="cp">#define ANY 1 </span><span class="c1">// auth or replica
</span><span class="c1"></span><span class="cp">#define AUTH 2 </span><span class="c1">// auth only
</span><span class="c1"></span><span class="cp">#define XCL 3 </span><span class="c1">// auth or exclusive client
</span><span class="c1"></span>
<span class="c1">//#define FW 4 // fw to auth, if replica
</span><span class="c1"></span>
<span class="cp">#define REQ 5 </span><span class="c1">// req state change from auth, if replica
</span></code></pre></td></tr></table>
</div>
</div><p>状态分析</p>
<p>SYNC：一种任意人都可读，可加读锁的状态；</p>
<p>LOCK：在无副本的情况下，可多写的状态；</p>
<p>MIX：  在有副本的情况下，需要多写的状态；
主本、副本都是MIX态；
锁从MIX迁移到其他状态时，会自动汇总副本inode上的数</p>
<h3 id="五技术的底层原理和关键实现">五、技术的底层原理和关键实现</h3>
<h3 id="51--锁需要持久化吗">5.1  锁需要持久化吗？</h3>
<p>Ceph 文件系统 ( <strong>CephFS</strong> ) 它构建于 Ceph 的分布式对象存储 <strong>RADOS</strong> 之上</p>
<p><img src="https://docs.ceph.com/en/reef/_images/cephfs-architecture.svg" alt="MDS 不会在本地存储任何元数据状态"></p>
<p>锁状态机定义(sm_state_t)本身不需要持久化，它是代码中的静态结构。</p>
<p>但锁的当前状态需要持久化，这是通过以下机制实现的：</p>
<ol>
<li>MDS将当前的锁状态通过日志机制 或者元数据对象两种方式持久化</li>
<li>锁状态变更 → 日志记录(EUpdate) → 日志对象 → 定期写入元数据</li>
<li>编码方面持久化void CInode::encode_lock_state(int type, bufferlist&amp; bl)</li>
<li>锁状态变更通过日志事务记录
EUpdate *le = new EUpdate(mdlog, &ldquo;updated lock&rdquo;);</li>
<li>日志记录最终会转化为元数据存储</li>
<li>元数据存储到RADOS</li>
</ol>
<ul>
<li>锁状态会作为inode/dentry的一部分存储到RADOS对象</li>
</ul>
<h4 id="cinodestore">CInode::store</h4>
<p>-<code>CInode::store</code> 函数的主要目的是将当前的 inode（文件元数据）编码并写入到底层的 RADOS 对象存储中。​</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 将内存中的 CInode 元数据持久化到 RADOS 存储池
</span><span class="c1"></span><span class="kt">void</span> <span class="n">CInode</span><span class="o">::</span><span class="n">store</span><span class="p">(</span><span class="n">MDSContext</span> <span class="o">*</span><span class="n">fin</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cm">/********************* 数据序列化阶段 *********************/</span>
    <span class="n">bufferlist</span> <span class="n">bl</span><span class="p">;</span> <span class="c1">// 存储序列化后的二进制数据
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">magic</span> <span class="o">=</span> <span class="n">CEPH_FS_ONDISK_MAGIC</span><span class="p">;</span> 
    <span class="n">encode</span><span class="p">(</span><span class="n">magic</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span> <span class="c1">// 写入魔数（校验用）
</span><span class="c1"></span>    <span class="c1">// 将 CInode 的元数据（如 inode 号、权限、时间戳等）序列化到 bl 中
</span><span class="c1"></span>    <span class="n">encode_store</span><span class="p">(</span><span class="n">bl</span><span class="p">,</span> <span class="n">mdcache</span><span class="o">-&gt;</span><span class="n">mds</span><span class="o">-&gt;</span><span class="n">mdsmap</span><span class="o">-&gt;</span><span class="n">get_up_features</span><span class="p">());</span>

    <span class="cm">/********************* 对象操作定义 *********************/</span>
    <span class="n">SnapContext</span> <span class="n">snapc</span><span class="p">;</span> <span class="c1">// 快照上下文（此处未显式关联快照）
</span><span class="c1"></span>    <span class="n">ObjectOperation</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// RADOS 对象操作指令
</span><span class="c1"></span>    <span class="n">m</span><span class="p">.</span><span class="n">write_full</span><span class="p">(</span><span class="n">bl</span><span class="p">);</span>  <span class="c1">// 全量覆盖写入（替换整个对象内容）
</span><span class="c1"></span>
    <span class="c1">// 构造元数据对象的唯一标识符（格式如 {ino}_head/.inode）
</span><span class="c1"></span>    <span class="n">object_t</span> <span class="n">oid</span> <span class="o">=</span> <span class="n">CInode</span><span class="o">::</span><span class="n">get_object_name</span><span class="p">(</span><span class="n">ino</span><span class="p">(),</span> <span class="n">frag_t</span><span class="p">(),</span> <span class="s">&#34;.inode&#34;</span><span class="p">);</span>
    <span class="c1">// 指定元数据存储池（metadata_pool，与数据池分离以优化性能
</span><span class="c1"></span>    <span class="n">object_locator_t</span> <span class="nf">oloc</span><span class="p">(</span><span class="n">mdcache</span><span class="o">-&gt;</span><span class="n">mds</span><span class="o">-&gt;</span><span class="n">get_metadata_pool</span><span class="p">());</span>

    <span class="cm">/********************* 异步写入与回调 *********************/</span>
    <span class="c1">// 创建回调链：
</span><span class="c1"></span>    <span class="n">Context</span> <span class="o">*</span><span class="n">newfin</span> <span class="o">=</span> <span class="n">new</span> <span class="n">C_OnFinisher</span><span class="p">(</span>
        <span class="n">new</span> <span class="n">C_IO_Inode_Stored</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">get_version</span><span class="p">(),</span> <span class="n">fin</span><span class="p">),</span>
        <span class="n">mdcache</span><span class="o">-&gt;</span><span class="n">mds</span><span class="o">-&gt;</span><span class="n">finisher</span>
    <span class="p">);</span>
    <span class="c1">// 通过 Objecter 发起异步写入请求（底层调用 librados）
</span><span class="c1"></span>    <span class="n">mdcache</span><span class="o">-&gt;</span><span class="n">mds</span><span class="o">-&gt;</span><span class="n">objecter</span><span class="o">-&gt;</span><span class="n">mutate</span><span class="p">(</span>
        <span class="n">oid</span><span class="p">,</span> <span class="n">oloc</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">snapc</span><span class="p">,</span> 
        <span class="n">ceph</span><span class="o">::</span><span class="n">real_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newfin</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="7-恢复机制">7 恢复机制</h4>
<p>MDS重启或集群故障转移时，锁状态会从持久化存储恢复：</p>
<ul>
<li>handle_mds_map state change up:boot &ndash;&gt; up:replay</li>
<li>handle_mds_map state change up:replay &ndash;&gt; up:reconnect</li>
<li>handle_mds_map state change up:reconnect &ndash;&gt; up:rejoin</li>
<li>handle_mds_map state change up:rejoin &ndash;&gt; up:active</li>
</ul>
<h3 id="52-为什么是自驱">5.2 为什么是自驱</h3>
<p>锁类型与锁状态的区别</p>
<p>重要的是区分锁类型(不可变)和锁状态(可变):</p>
<ol>
<li>锁类型：由类的继承关系确定，表示锁的功能和行为模式，不可转换</li>
</ol>
<ul>
<li>LocalLock、SimpleLock、ScatterLock、FileLock</li>
</ul>
<ol>
<li>锁状态：锁在其生命周期中的当前状态，可以转换</li>
</ol>
<ul>
<li>LOCK_SYNC、LOCK_EXCL、LOCK_MIX等</li>
</ul>
<h4 id="ceph锁机制的自我调节特性">Ceph锁机制的自我调节特性</h4>
<p>在Ceph中，锁状态转换具有自我驱动的特性，这是分布式系统中的一个关键设计。让我用简单的方式解释这个概念：</p>
<p>当说&quot;锁机制依据各种条件自我驱动到合适的状态，无需业务主动干预&quot;时，意思是：</p>
<ol>
<li>
<p>自动状态优化：锁系统会根据当前系统状态和访问模式，自动调整锁的状态</p>
</li>
<li>
<p>透明于上层：上层业务代码不需要显式管理这些状态转换</p>
</li>
<li>
<p>智能适应：锁会根据使用情况&quot;学习&quot;并调整到最适合的状态</p>
</li>
</ol>
<h4 id="实际例子文件锁filelock自动调节">实际例子：文件锁(FileLock)自动调节</h4>
<p>假设一个场景，文件先被单客户端写入，后来变成多客户端读取：</p>
<p>阶段1: 客户端A独占写入文件</p>
<p>- FileLock自动转为EXCL状态(独占)
- 提供完整的写入权限</p>
<p>阶段2: 客户端A写完，多个客户端开始读取</p>
<p>- 系统检测到访问模式变化</p>
<p>- FileLock自动评估并转为SYNC状态(共享)</p>
<p>- 优化为多读取场景</p>
<p>整个过程中，业务层只请求了&quot;我需要读&quot;或&quot;我需要写&quot;，而不需关心锁处于什么状态。</p>
<h5 id="评估函数示例">评估函数示例</h5>
<p>看一个简化的file_eval函数，它负责评估文件锁状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/ceph/ceph/blob/main/src/mds/Locker.cc
</span><span class="c1"></span>
<span class="kt">void</span> <span class="n">Locker</span><span class="o">::</span><span class="n">file_eval</span><span class="p">(</span><span class="n">ScatterLock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">need_issue</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 分析当前需求
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">wanted</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">get_caps_wanted</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loner_wanted</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_wanted</span><span class="p">);</span>

  <span class="c1">// 当前是EXCL但不再需要独占
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">get_state</span><span class="p">()</span> <span class="o">==</span> <span class="n">LOCK_EXCL</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">loner_wanted</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_ANY_FILE_WR</span><span class="p">))</span> <span class="o">||</span>

        <span class="p">(</span><span class="n">other_wanted</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_GEXCL</span><span class="o">|</span><span class="n">CEPH_CAP_GRD</span><span class="p">)))</span> <span class="p">{</span>

      <span class="c1">// 自动转到更合适的状态
</span><span class="c1"></span>
      <span class="k">if</span> <span class="p">(</span><span class="n">other_wanted</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GWR</span><span class="p">)</span>

        <span class="n">scatter_mix</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">need_issue</span><span class="p">);</span>  <span class="c1">// 转到MIX
</span><span class="c1"></span>
      <span class="k">else</span>

        <span class="nf">simple_sync</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">need_issue</span><span class="p">);</span>  <span class="c1">// 转到SYNC
</span><span class="c1"></span>
    <span class="p">}</span>

  <span class="p">}</span>

  <span class="c1">// 当前不是EXCL但需要独占
</span><span class="c1"></span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">get_state</span><span class="p">()</span> <span class="o">!=</span> <span class="n">LOCK_EXCL</span> <span class="o">&amp;&amp;</span>

           <span class="n">in</span><span class="o">-&gt;</span><span class="n">get_target_loner</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>

           <span class="p">(</span><span class="n">wanted</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_ANY_FILE_WR</span><span class="p">)))</span> <span class="p">{</span>

    <span class="n">file_excl</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">need_issue</span><span class="p">);</span>  <span class="c1">// 转到EXCL
</span><span class="c1"></span>
  <span class="p">}</span>
  <span class="c1">// 自动优化其他状态...
</span><span class="c1"></span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种设计的优势</p>
<ol>
<li>
<p>降低复杂度：上层代码不需理解复杂的锁状态</p>
</li>
<li>
<p>自适应优化：系统根据实际使用模式自动优化</p>
</li>
<li>
<p>性能提升：锁状态总是趋向于最高效的配置</p>
</li>
<li>
<p>减少人为错误：避免手动状态管理的错误</p>
</li>
</ol>
<p>)</p>
<h4 id="案例-2scatterlock在ceph中的真实应用目录统计信息">案例 2：ScatterLock在Ceph中的真实应用：目录统计信息</h4>
<p>问题背景</p>
<ul>
<li>
<p>大型目录可能包含数百万文件</p>
</li>
<li>
<p>多个客户端在不同位置并发创建/删除文件</p>
</li>
<li>
<p>需要维护准确的目录统计信息(文件数、总大小等)</p>
</li>
</ul>
<h3 id="六已有的实现和它之间的对比">六、已有的实现和它之间的对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>CephFS 分布式锁</th>
<th>Redis（Redlock）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>集成度</strong></td>
<td>与 RADOS 对象存储深度耦合，锁信息作为对象属性由 MDS 内部 <code>mds.locker</code> 模块全权管理</td>
<td>依赖外部 Redis 实例，通过客户端执行原子命令（<code>SET NX PX</code> 等）实现，无需底层存储集成</td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>细粒度：支持多种锁类型，包括目录项锁（SimpleLock）、目录统计锁（ScatterLock）、文件锁（FileLock）等</td>
<td>粗粒度：按单个 key 加锁，通常一个资源对应一个 Redis key；Redlock 通过在多数实例上加锁来实现互斥</td>
</tr>
<tr>
<td><strong>故障模型</strong></td>
<td>支持 active–standby（基于日志重放秒级接管）与 active–active（目录子树隔离故障影响范围最小）两种模式，依靠 RADOS 多副本保障一致性</td>
<td>基于租约（TTL）与多数派原则：客户端需在多数 Redis 实例上在租约时间内成功加锁，部分实例故障时仍能保证锁安全</td>
</tr>
<tr>
<td><strong>性能（延迟）</strong></td>
<td>中等：每次加解锁需通过 MDS RPC 并写入 per-MDS 日志到 RADOS，读多写少时可依靠 capability 缓存显著降低延迟</td>
<td>极低：锁操作在内存中完成，单实例场景下通常只需一次网络往返，多实例 Redlock 也仅需少量命令</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>通过动态子树分区（Dynamic Subtree Partitioning）实现 MDS 水平线性扩展与元数据负载均衡</td>
<td>受限于 Redis 实例数量和分片拓扑，跨分片锁定需额外协调，大规模场景中扩展性有限</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>高：涉及多种锁类型与状态机、cap 回收逻辑、MDS 与 RADOS 之间的日志同步与故障切换，运维和调优成本较大</td>
<td>低：实现逻辑简单，主要由客户端库负责，但需注意时钟漂移和网络抖动带来的租约安全问题</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<ul>
<li>高度抽象 ，把锁变成面向对象设计，抽象不同类型的锁</li>
<li><strong>锁转换的触发机制</strong>，需要结合业务深入分析</li>
<li>锁状态变化随着文件indoe等信息进行 持久化</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>【1】https://docs.ceph.com/en/reef/cephfs</p>
</li>
<li>
<p>【2】mkdir|mksnap流程源码分析|锁状态切换实例</p>
</li>
<li>
<p>【3】https://github.com/ceph/ceph/blob/main/doc/cephfs/mds-states.rst</p>
</li>
<li>
<p>【4】https://docs.ceph.com/en/latest/dev/mds_internals/locking/</p>
<p>如果您觉得阅读本文对您有帮助，
请点一下“<strong>点赞，转发</strong>” 按钮，
您的“<strong>点赞，转发</strong>” 将是我最大的写作动力！</p>
</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Troy</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2024-08-07 00:00
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a target="_blank" rel="license noopener" href="https://github.com/nusr/blog/blob/master/LICENSE">MIT</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/LINUX%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">LINUX系统调用</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/future_for_ai/c&#43;&#43;/01_c&#43;&#43;_new/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">c&#43;&#43;入门指南</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/habit/2025/2025-%E5%B9%B4-6-%E6%9C%88-%E8%B5%B7%E5%BA%8A%E7%9B%AE%E6%A0%87/">
            <span class="next-text nav-default">不是不努力，而是不健康</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="wangcy6/wangcy6.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wang_cyi@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/wangcy6" class="iconfont icon-github" title="github"></a>
  <a href="https://wangcy6.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Troy</span>
  </span>
</div>
<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138883536-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
